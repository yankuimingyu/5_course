###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.2.7424/W32 for ARM        14/May/2017  11:28:18
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpg_common\drivers\messaging.c
#    Command line =  
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpg_common\drivers\messaging.c
#        -D MPGL1 -D MPG1 -D EIE1 --preprocess=cl
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\Debug\List\
#        -lC
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\Debug\List\
#        -o
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\ -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\..\bsp\
#        -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\..\drivers\
#        -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\..\application\
#        -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\
#        -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\application\
#        -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\cmsis\
#        -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\Debug\List\messaging.lst
#    Object file  =  
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\Debug\Obj\messaging.o
#
###############################################################################

D:\Documents\GitHub\5-5eie\5_course\firmware_mpg_common\drivers\messaging.c
      1          /**********************************************************************************************************************
      2          File: messaging.c                                                                
      3          
      4          Description:
      5          This file contains utilities to create and monitor outgoing messages.  It essentially provides a 
      6          smart queue system for outgoing data.
      7          Any message being transferred by a peripheral is kept here.  As the peripheral sends the message,
      8          it talks to messaging.c to get data and update the message status.  
      9          All interaction between the peripheral and this task is through unique message tokens that are assigned
     10          to every message queued to messaging.c
     11          ------------------------------------------------------------------------------------------------------------------------
     12          API:
     13          
     14          TYPES
     15          MessageStateType: enum status of a message in the queue
     16          EMPTY, WAITING, SENDING, RECEIVING, COMPLETE, TIMEOUT, ABANDONED, NOT_FOUND
     17          
     18          MessageType: linked-list style entry with token, size, data pointer and next MessageType pointer
     19          
     20          MessageSlot: member of the message queue holding the free/full status of a particular queue location and a pointer to its data
     21          
     22          MessageStatus: token, state and timestamp of a message in the queue
     23          
     24          FUNCTIONS
     25          Public:
     26          MessageStateType QueryMessageStatus(u32 u32Token_)
     27          Queries the current status of the message with u32Token.  If the message has completed or timed out, the query will
     28          cause the message status to be removed from the status queue.
     29          
     30          Protected:
     31          void MessagingInitialize(void)
     32          One-time call to start the messaging application.
     33          
     34          u32 QueueMessage(MessageType** eTargetTxBuffer_, u32 u32MessageSize_, u8* pu8MessageData_)
     35          Adds a message to the correct data queue, assigns a token which is posted to the status queue and returned to the client.
     36          This function is Protected because tasks that can queue messages should be managed carefully and not granted free reign
     37          to queue messages.  The message queue is a finite resource with TX_QUEUE_SIZE slots available for messages.
     38          We avoid dynamic allocation due to the inherent issues with fragmentation on resource-limited systems.
     39          
     40          void DeQueueMessage(MessageType** pTargetQueue_)
     41          Removes a message from the message queue (typically since all the bytes have been submitted to the communication peripheral
     42          which is sending the message.  The message status is updated in the status queue.
     43          
     44          void UpdateMessageStatus(u32 u32Token_, MessageStateType eNewState_)
     45          Changes the status of a message in the statue queue.
     46          
     47          **********************************************************************************************************************/
     48          
     49          #include "configuration.h"
     50          
     51          /***********************************************************************************************************************
     52          Global variable definitions with scope across entire project.
     53          All Global variable names shall start with "G_xxMessaging"
     54          ***********************************************************************************************************************/
     55          /* New variables */

   \                                 In section .bss, align 4
     56          u32 G_u32MessagingFlags;                                 /* Global state flags */
   \                     G_u32MessagingFlags:
   \   00000000                      DS8 4
     57          
     58          /*--------------------------------------------------------------------------------------------------------------------*/
     59          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     60          extern volatile u32 G_u32SystemFlags;                    /* From main.c */
     61          extern volatile u32 G_u32ApplicationFlags;               /* From main.c */
     62          
     63          extern volatile u32 G_u32SystemTime1ms;                  /* From board-specific source file */
     64          extern volatile u32 G_u32SystemTime1s;                   /* From board-specific source file */
     65          
     66          
     67          /***********************************************************************************************************************
     68          Global variable definitions with scope limited to this local application.
     69          Variable names shall start with "Msg_" and be declared as static.
     70          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     71          static fnCode_type Messaging_pfnStateMachine;            /* The state machine function pointer */
   \                     Messaging_pfnStateMachine:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     72          static u32 Msg_u32Token;                                 /* Incrementing message token used for all external communications */
   \                     Msg_u32Token:
   \   00000000                      DS8 4
     73          

   \                                 In section .bss, align 4
     74          static MessageSlot Msg_Pool[TX_QUEUE_SIZE];              /* Array of MessageSlot used for the transmit queue */
   \                     Msg_Pool:
   \   00000000                      DS8 2304

   \                                 In section .bss, align 1
     75          static u8 Msg_u8QueuedMessageCount;                      /* Number of messages slots currently occupied */
   \                     Msg_u8QueuedMessageCount:
   \   00000000                      DS8 1
     76          
     77          /* A separate status queue needs to be maintained since the message information in Msg_Pool will be lost when the message
     78          has been dequeued.  Applications must be able to query to determine the status of their message, particularly if
     79          it has been sent. */

   \                                 In section .bss, align 4
     80          static MessageStatus Msg_StatusQueue[STATUS_QUEUE_SIZE]; /* Array of MessageStatus used to monitor message status */
   \                     Msg_StatusQueue:
   \   00000000                      DS8 768

   \                                 In section .bss, align 4
     81          static MessageStatus* Msg_pNextStatus;                   /* Pointer to next available message status */
   \                     Msg_pNextStatus:
   \   00000000                      DS8 4
     82          
     83          
     84          /**********************************************************************************************************************
     85          Function Definitions
     86          **********************************************************************************************************************/
     87          
     88          /*--------------------------------------------------------------------------------------------------------------------*/
     89          /* Public Functions */
     90          /*--------------------------------------------------------------------------------------------------------------------*/
     91          
     92          /*----------------------------------------------------------------------------------------------------------------------
     93          Function: QueryMessageStatus()
     94          
     95          Description:
     96          Checks the state of a message.  If the state is COMPLETE or TIMEOUT, the status is deleted from the message queue.
     97          Since the queue is quite short, most of the time it will hold very little entires.  New entries are always filled at the front,
     98          using a simple linear search starting at index 0.
     99          
    100          Requires:
    101            - u32Token_ is the token of the message of interest
    102          
    103          Promises:
    104            - Returns MessageStateType indicating the status of the message
    105            - if the message is found in COMPLETE or TIMEOUT state, the status is removed from the queue
    106          */

   \                                 In section .text, align 2, keep-with-next
    107          MessageStateType QueryMessageStatus(u32 u32Token_)
    108          {
   \                     QueryMessageStatus: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    109            MessageStateType eStatus   = NOT_FOUND;
   \   00000002   0x20FF             MOVS     R0,#+255
    110            MessageStatus* pListParser = &Msg_StatusQueue[0];
   \   00000004   0x....             LDR.N    R2,??DataTable8
    111            
    112            /* Brute force search for the token - the queue will never be large enough on this system to require a more
    113            intelligent search algorithm */
    114            while( (pListParser->u32Token != u32Token_) && (pListParser != &Msg_StatusQueue[STATUS_QUEUE_SIZE]) )
   \                     ??QueryMessageStatus_0: (+1)
   \   00000006   0x6813             LDR      R3,[R2, #+0]
   \   00000008   0x428B             CMP      R3,R1
   \   0000000A   0xD004             BEQ.N    ??QueryMessageStatus_1
   \   0000000C   0x....             LDR.N    R3,??DataTable8_1
   \   0000000E   0x429A             CMP      R2,R3
   \   00000010   0xD001             BEQ.N    ??QueryMessageStatus_1
    115            {
    116              pListParser++;
   \   00000012   0x320C             ADDS     R2,R2,#+12
   \   00000014   0xE7F7             B.N      ??QueryMessageStatus_0
    117            }
    118          
    119            /* If the token was found pListParser is pointing at it, take appropriate action */
    120            if(pListParser != &Msg_StatusQueue[STATUS_QUEUE_SIZE])
   \                     ??QueryMessageStatus_1: (+1)
   \   00000016   0x....             LDR.N    R3,??DataTable8_1
   \   00000018   0x429A             CMP      R2,R3
   \   0000001A   0xD00B             BEQ.N    ??QueryMessageStatus_2
    121            {
    122              /* Save the status */
    123              eStatus = pListParser->eState;
   \   0000001C   0x7913             LDRB     R3,[R2, #+4]
   \   0000001E   0x0018             MOVS     R0,R3
    124          
    125              /* Release the slot if the message state is final (the client must deal with it now) */
    126              if( (eStatus == COMPLETE) || (eStatus == TIMEOUT) )
   \   00000020   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000022   0x2804             CMP      R0,#+4
   \   00000024   0xD002             BEQ.N    ??QueryMessageStatus_3
   \   00000026   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000028   0x2805             CMP      R0,#+5
   \   0000002A   0xD103             BNE.N    ??QueryMessageStatus_2
    127              {
    128                pListParser->u32Token = 0;
   \                     ??QueryMessageStatus_3: (+1)
   \   0000002C   0x2300             MOVS     R3,#+0
   \   0000002E   0x6013             STR      R3,[R2, #+0]
    129                pListParser->eState = EMPTY;
   \   00000030   0x2300             MOVS     R3,#+0
   \   00000032   0x7113             STRB     R3,[R2, #+4]
    130              }
    131            }
    132          
    133            return(eStatus);
   \                     ??QueryMessageStatus_2: (+1)
   \   00000034   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000036   0x4770             BX       LR               ;; return
    134            
    135          } /* end QueryMessageStatus() */
    136          
    137          
    138          /*--------------------------------------------------------------------------------------------------------------------*/
    139          /* Protected Functions */
    140          /*--------------------------------------------------------------------------------------------------------------------*/
    141          
    142          /*----------------------------------------------------------------------------------------------------------------------
    143          Function: QueueMessage
    144          
    145          Description:
    146          Allocates one of the positions in the message queue to the calling function's send queue.
    147          
    148          Requires:
    149            - eTargetTxBuffer_ is the peripheral transmit buffer where the message will be queued
    150            - u32MessageSize_ is the size of the message data array in bytes
    151            - pu8MessageData_ points to the message data array
    152            - Msg_Pool should not be full 
    153          
    154          Promises:
    155            - The message is inserted into the target list and assigned a token
    156            - If the message is created successfully, the message token is returned; otherwise, NULL is returned
    157          */

   \                                 In section .text, align 2, keep-with-next
    158          u32 QueueMessage(MessageType** eTargetTxBuffer_, u32 u32MessageSize_, u8* pu8MessageData_)
    159          {
   \                     QueueMessage: (+1)
   \   00000000   0xE92D 0x4FF8      PUSH     {R3-R11,LR}
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
   \   00000008   0x0016             MOVS     R6,R2
    160            MessageSlot *psSlotParser;
    161            MessageType *psNewMessage;
    162            MessageType *psListParser;
    163            u32 u32BytesRemaining = u32MessageSize_;
   \   0000000A   0x46AB             MOV      R11,R5
    164            u32 u32CurrentMessageSize = 0;
   \   0000000C   0xF05F 0x0900      MOVS     R9,#+0
    165            
    166            /* Check for available space in the message pool */
    167            if(Msg_u8QueuedMessageCount == TX_QUEUE_SIZE)
   \   00000010   0x....             LDR.N    R0,??DataTable8_2
   \   00000012   0x7800             LDRB     R0,[R0, #+0]
   \   00000014   0x2810             CMP      R0,#+16
   \   00000016   0xD107             BNE.N    ??QueueMessage_0
    168            {
    169              G_u32MessagingFlags |= _MESSAGING_TX_QUEUE_FULL;
   \   00000018   0x....             LDR.N    R0,??DataTable8_3
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000020   0x....             LDR.N    R1,??DataTable8_3
   \   00000022   0x6008             STR      R0,[R1, #+0]
    170              return(0);
   \   00000024   0x2000             MOVS     R0,#+0
   \   00000026   0xE066             B.N      ??QueueMessage_1
    171            }
    172          
    173            /* Space available, so proceed with allocation.  Though only one message is queued at a time, we
    174            use a while loop to handle messages that are too big and must be split into different slots.  The slots
    175            are always sequential and the message processor will send the bytes continuously across slots */
    176            while(u32BytesRemaining)
   \                     ??QueueMessage_0: (+1)
   \   00000028   0xF1BB 0x0F00      CMP      R11,#+0
   \   0000002C   0xD062             BEQ.N    ??QueueMessage_2
    177            {
    178              Msg_u8QueuedMessageCount++;
   \   0000002E   0x....             LDR.N    R0,??DataTable8_2
   \   00000030   0x7800             LDRB     R0,[R0, #+0]
   \   00000032   0x1C40             ADDS     R0,R0,#+1
   \   00000034   0x....             LDR.N    R1,??DataTable8_2
   \   00000036   0x7008             STRB     R0,[R1, #+0]
    179              
    180              /* Flag if we're above the high watermark */
    181              if(Msg_u8QueuedMessageCount >= TX_QUEUE_WATERMARK)
   \   00000038   0x....             LDR.N    R0,??DataTable8_2
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x280E             CMP      R0,#+14
   \   0000003E   0xDB06             BLT.N    ??QueueMessage_3
    182              {
    183                G_u32MessagingFlags |= _MESSAGING_TX_QUEUE_ALMOST_FULL;
   \   00000040   0x....             LDR.N    R0,??DataTable8_3
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000048   0x....             LDR.N    R1,??DataTable8_3
   \   0000004A   0x6008             STR      R0,[R1, #+0]
   \   0000004C   0xE005             B.N      ??QueueMessage_4
    184              }
    185              else
    186              {
    187                G_u32MessagingFlags &= ~_MESSAGING_TX_QUEUE_ALMOST_FULL;
   \                     ??QueueMessage_3: (+1)
   \   0000004E   0x....             LDR.N    R0,??DataTable8_3
   \   00000050   0x6800             LDR      R0,[R0, #+0]
   \   00000052   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000056   0x....             LDR.N    R1,??DataTable8_3
   \   00000058   0x6008             STR      R0,[R1, #+0]
    188              }
    189              
    190              /* Find an empty slot: this is non-circular and there must be at least one free slot if we're here */
    191              psSlotParser = &Msg_Pool[0];
   \                     ??QueueMessage_4: (+1)
   \   0000005A   0x....             LDR.N    R0,??DataTable8_4
   \   0000005C   0x4682             MOV      R10,R0
    192              while(!psSlotParser->bFree)
   \                     ??QueueMessage_5: (+1)
   \   0000005E   0xF89A 0x0000      LDRB     R0,[R10, #+0]
   \   00000062   0x2800             CMP      R0,#+0
   \   00000064   0xD102             BNE.N    ??QueueMessage_6
    193              {
    194                psSlotParser++;
   \   00000066   0xF11A 0x0A90      ADDS     R10,R10,#+144
   \   0000006A   0xE7F8             B.N      ??QueueMessage_5
    195              }
    196              
    197              /* Allocate the slot and set the message pointer */
    198              psSlotParser->bFree = FALSE;
   \                     ??QueueMessage_6: (+1)
   \   0000006C   0x2000             MOVS     R0,#+0
   \   0000006E   0xF88A 0x0000      STRB     R0,[R10, #+0]
    199              psNewMessage = &(psSlotParser->Message);
   \   00000072   0xF11A 0x0004      ADDS     R0,R10,#+4
   \   00000076   0x0007             MOVS     R7,R0
    200            
    201              /* Check the message size and split the message up if necessary */
    202              if(u32BytesRemaining > MAX_TX_MESSAGE_LENGTH)
   \   00000078   0xF1BB 0x0F81      CMP      R11,#+129
   \   0000007C   0xD304             BCC.N    ??QueueMessage_7
    203              {
    204                u32CurrentMessageSize = MAX_TX_MESSAGE_LENGTH;
   \   0000007E   0x2080             MOVS     R0,#+128
   \   00000080   0x4681             MOV      R9,R0
    205                u32BytesRemaining -= MAX_TX_MESSAGE_LENGTH;
   \   00000082   0xF1BB 0x0B80      SUBS     R11,R11,#+128
   \   00000086   0xE002             B.N      ??QueueMessage_8
    206              }
    207              else
    208              {
    209                u32CurrentMessageSize = u32BytesRemaining;
   \                     ??QueueMessage_7: (+1)
   \   00000088   0x46D9             MOV      R9,R11
    210                u32BytesRemaining = 0;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x4683             MOV      R11,R0
    211              }
    212              
    213              /* Copy all the data to the allocated message structure */
    214              psNewMessage->u32Token      = Msg_u32Token;
   \                     ??QueueMessage_8: (+1)
   \   0000008E   0x....             LDR.N    R0,??DataTable8_5
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0x6038             STR      R0,[R7, #+0]
    215              psNewMessage->u32Size       = u32CurrentMessageSize;
   \   00000094   0xF8C7 0x9004      STR      R9,[R7, #+4]
    216              psNewMessage->psNextMessage = NULL;
   \   00000098   0x2000             MOVS     R0,#+0
   \   0000009A   0xF8C7 0x0088      STR      R0,[R7, #+136]
    217              
    218              /* Add the data into the payload */
    219              for(u32 i = 0; i < psNewMessage->u32Size; i++)
   \   0000009E   0x2000             MOVS     R0,#+0
   \                     ??QueueMessage_9: (+1)
   \   000000A0   0x6879             LDR      R1,[R7, #+4]
   \   000000A2   0x4288             CMP      R0,R1
   \   000000A4   0xD205             BCS.N    ??QueueMessage_10
    220              {
    221                *(psNewMessage->pu8Message + i) = *pu8MessageData_++;
   \   000000A6   0x7831             LDRB     R1,[R6, #+0]
   \   000000A8   0x19C2             ADDS     R2,R0,R7
   \   000000AA   0x7211             STRB     R1,[R2, #+8]
   \   000000AC   0x1C76             ADDS     R6,R6,#+1
    222              }
   \   000000AE   0x1C40             ADDS     R0,R0,#+1
   \   000000B0   0xE7F6             B.N      ??QueueMessage_9
    223            
    224              /* Link the new message into the client's transmit buffer */
    225              /* Handle an empty list */
    226              if(*eTargetTxBuffer_ == NULL)
   \                     ??QueueMessage_10: (+1)
   \   000000B2   0x6820             LDR      R0,[R4, #+0]
   \   000000B4   0x2800             CMP      R0,#+0
   \   000000B6   0xD101             BNE.N    ??QueueMessage_11
    227              {
    228                *eTargetTxBuffer_ = psNewMessage;
   \   000000B8   0x6027             STR      R7,[R4, #+0]
   \   000000BA   0xE00A             B.N      ??QueueMessage_12
    229              }
    230          
    231              /* Add the message to the end of the list */
    232              else
    233              {
    234                /* Find the last node */
    235                psListParser =  *eTargetTxBuffer_;
   \                     ??QueueMessage_11: (+1)
   \   000000BC   0x6820             LDR      R0,[R4, #+0]
   \   000000BE   0x4680             MOV      R8,R0
    236                while(psListParser->psNextMessage != NULL)
   \                     ??QueueMessage_13: (+1)
   \   000000C0   0xF8D8 0x0088      LDR      R0,[R8, #+136]
   \   000000C4   0x2800             CMP      R0,#+0
   \   000000C6   0xD002             BEQ.N    ??QueueMessage_14
    237                {
    238                  psListParser = psListParser->psNextMessage;
   \   000000C8   0xF8D8 0x8088      LDR      R8,[R8, #+136]
   \   000000CC   0xE7F8             B.N      ??QueueMessage_13
    239                }
    240               
    241                /* Found the end: add the new node */
    242                psListParser->psNextMessage = psNewMessage;
   \                     ??QueueMessage_14: (+1)
   \   000000CE   0xF8C8 0x7088      STR      R7,[R8, #+136]
    243              }
    244            
    245              /* Update the Public status of the message in the status queue */
    246              AddNewMessageStatus(Msg_u32Token);
   \                     ??QueueMessage_12: (+1)
   \   000000D2   0x....             LDR.N    R0,??DataTable8_5
   \   000000D4   0x6800             LDR      R0,[R0, #+0]
   \   000000D6   0x.... 0x....      BL       AddNewMessageStatus
    247            
    248              /* Increment message token and catch the rollover every 4 billion messages... Token 0 is not allowed. */
    249              if(++Msg_u32Token == 0)
   \   000000DA   0x....             LDR.N    R0,??DataTable8_5
   \   000000DC   0x6800             LDR      R0,[R0, #+0]
   \   000000DE   0x1C40             ADDS     R0,R0,#+1
   \   000000E0   0x....             LDR.N    R1,??DataTable8_5
   \   000000E2   0x6008             STR      R0,[R1, #+0]
   \   000000E4   0x....             LDR.N    R0,??DataTable8_5
   \   000000E6   0x6800             LDR      R0,[R0, #+0]
   \   000000E8   0x2800             CMP      R0,#+0
   \   000000EA   0xD19D             BNE.N    ??QueueMessage_0
    250              {
    251                Msg_u32Token = 1;
   \   000000EC   0x2001             MOVS     R0,#+1
   \   000000EE   0x....             LDR.N    R1,??DataTable8_5
   \   000000F0   0x6008             STR      R0,[R1, #+0]
   \   000000F2   0xE799             B.N      ??QueueMessage_0
    252              }
    253            
    254            } /* end while */
    255          
    256            /* Return only the current (and highest) message token, as it will be the last portion to be sent if the message was split up */
    257            return(psNewMessage->u32Token);
   \                     ??QueueMessage_2: (+1)
   \   000000F4   0x6838             LDR      R0,[R7, #+0]
   \                     ??QueueMessage_1: (+1)
   \   000000F6   0xE8BD 0x8FF2      POP      {R1,R4-R11,PC}   ;; return
    258            
    259          } /* end QueueMessage() */
    260          
    261          
    262          /*----------------------------------------------------------------------------------------------------------------------
    263          Function: DeQueueMessage
    264          
    265          Description:
    266          Removes a message from a message queue and adds it back to the pool.
    267          
    268          Requires:
    269            - pTargetQueue_ points to the list queue where the message to be deleted is located
    270            - pTargetQueue_ is a FIFO linked-list where the message that needs to be killed is at the front of the list
    271            - The message to be removed has been completely sent and is no longer in use
    272            - New message cannot be added into the list during this function (via interrupts)
    273          
    274          Promises:
    275            - The first message in the list is deleted; the list is hooked back up
    276            - The message space is added back to the available message queue
    277          */

   \                                 In section .text, align 2, keep-with-next
    278          void DeQueueMessage(MessageType** pTargetQueue_)
    279          {
    280            MessageSlot *psSlotParser;
    281                
    282            /* Make sure there is a message to kill */
    283            if(*pTargetQueue_ == NULL)
   \                     DeQueueMessage: (+1)
   \   00000000   0x6802             LDR      R2,[R0, #+0]
   \   00000002   0x2A00             CMP      R2,#+0
   \   00000004   0xD106             BNE.N    ??DeQueueMessage_0
    284            {
    285              G_u32MessagingFlags |= _DEQUEUE_GOT_NULL;
   \   00000006   0x....             LDR.N    R2,??DataTable8_3
   \   00000008   0x6812             LDR      R2,[R2, #+0]
   \   0000000A   0xF052 0x0204      ORRS     R2,R2,#0x4
   \   0000000E   0x....             LDR.N    R3,??DataTable8_3
   \   00000010   0x601A             STR      R2,[R3, #+0]
    286              return;
   \   00000012   0xE01F             B.N      ??DeQueueMessage_1
    287            }
    288            
    289            /* Find the message's slot: this message pool is non-circular and the message must be one of the slots */
    290            psSlotParser = &Msg_Pool[0];
   \                     ??DeQueueMessage_0: (+1)
   \   00000014   0x....             LDR.N    R2,??DataTable8_4
   \   00000016   0x0011             MOVS     R1,R2
    291            while( (&psSlotParser->Message != *pTargetQueue_) && (psSlotParser != &Msg_Pool[TX_QUEUE_SIZE]) )
   \                     ??DeQueueMessage_2: (+1)
   \   00000018   0x1D0A             ADDS     R2,R1,#+4
   \   0000001A   0x6803             LDR      R3,[R0, #+0]
   \   0000001C   0x429A             CMP      R2,R3
   \   0000001E   0xD004             BEQ.N    ??DeQueueMessage_3
   \   00000020   0x....             LDR.N    R2,??DataTable8_6
   \   00000022   0x4291             CMP      R1,R2
   \   00000024   0xD001             BEQ.N    ??DeQueueMessage_3
    292            {
    293              psSlotParser++;
   \   00000026   0x3190             ADDS     R1,R1,#+144
   \   00000028   0xE7F6             B.N      ??DeQueueMessage_2
    294            }
    295          
    296            /* Make sure the message has been found */
    297            if(psSlotParser == &Msg_Pool[TX_QUEUE_SIZE])
   \                     ??DeQueueMessage_3: (+1)
   \   0000002A   0x....             LDR.N    R2,??DataTable8_6
   \   0000002C   0x4291             CMP      R1,R2
   \   0000002E   0xD106             BNE.N    ??DeQueueMessage_4
    298            {
    299              G_u32MessagingFlags |= _DEQUEUE_MSG_NOT_FOUND;
   \   00000030   0x....             LDR.N    R2,??DataTable8_3
   \   00000032   0x6812             LDR      R2,[R2, #+0]
   \   00000034   0xF052 0x0208      ORRS     R2,R2,#0x8
   \   00000038   0x....             LDR.N    R3,??DataTable8_3
   \   0000003A   0x601A             STR      R2,[R3, #+0]
    300              return;
   \   0000003C   0xE00A             B.N      ??DeQueueMessage_1
    301            }
    302          
    303            /* Unhook the message from the current owner's queue and put it back in the pool */
    304            *pTargetQueue_ = (*pTargetQueue_)->psNextMessage;
   \                     ??DeQueueMessage_4: (+1)
   \   0000003E   0x6802             LDR      R2,[R0, #+0]
   \   00000040   0xF8D2 0x2088      LDR      R2,[R2, #+136]
   \   00000044   0x6002             STR      R2,[R0, #+0]
    305            psSlotParser->bFree = TRUE;
   \   00000046   0x2201             MOVS     R2,#+1
   \   00000048   0x700A             STRB     R2,[R1, #+0]
    306            Msg_u8QueuedMessageCount--;
   \   0000004A   0x....             LDR.N    R2,??DataTable8_2
   \   0000004C   0x7812             LDRB     R2,[R2, #+0]
   \   0000004E   0x1E52             SUBS     R2,R2,#+1
   \   00000050   0x....             LDR.N    R3,??DataTable8_2
   \   00000052   0x701A             STRB     R2,[R3, #+0]
    307            
    308          } /* end DeQueueMessage() */
   \                     ??DeQueueMessage_1: (+1)
   \   00000054   0x4770             BX       LR               ;; return
    309          
    310          
    311          /*--------------------------------------------------------------------------------------------------------------------
    312          Function: MessagingInitialize
    313          
    314          Description:
    315          Initializes the State Machine and its variables.
    316          
    317          Requires:
    318            - No messaging in progress
    319          
    320          Promises:
    321            - Message queues are zeroed
    322            - Flags and state machine are initialized
    323          */

   \                                 In section .text, align 2, keep-with-next
    324          void MessagingInitialize(void)
    325          {
    326            /* Inititalize variables */
    327            Msg_u8QueuedMessageCount = 0;
   \                     MessagingInitialize: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x....             LDR.N    R1,??DataTable8_2
   \   00000004   0x7008             STRB     R0,[R1, #+0]
    328            Msg_u32Token = 1;
   \   00000006   0x2001             MOVS     R0,#+1
   \   00000008   0x....             LDR.N    R1,??DataTable8_5
   \   0000000A   0x6008             STR      R0,[R1, #+0]
    329          
    330            /* Ensure all message slots are deallocated and the message status queue is empty */
    331            for(u16 i = 0; i < TX_QUEUE_SIZE; i++)
   \   0000000C   0x2000             MOVS     R0,#+0
   \                     ??MessagingInitialize_0: (+1)
   \   0000000E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000010   0x2810             CMP      R0,#+16
   \   00000012   0xDA08             BGE.N    ??MessagingInitialize_1
    332            {
    333              Msg_Pool[i].bFree = TRUE;
   \   00000014   0x2101             MOVS     R1,#+1
   \   00000016   0x....             LDR.N    R2,??DataTable8_4
   \   00000018   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000001A   0x2390             MOVS     R3,#+144
   \   0000001C   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000020   0x7011             STRB     R1,[R2, #+0]
    334            }
   \   00000022   0x1C40             ADDS     R0,R0,#+1
   \   00000024   0xE7F3             B.N      ??MessagingInitialize_0
    335          
    336            for(u16 i = 0; i < STATUS_QUEUE_SIZE; i++)
   \                     ??MessagingInitialize_1: (+1)
   \   00000026   0x2000             MOVS     R0,#+0
   \                     ??MessagingInitialize_2: (+1)
   \   00000028   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002A   0x2840             CMP      R0,#+64
   \   0000002C   0xDA16             BGE.N    ??MessagingInitialize_3
    337            {
    338              Msg_StatusQueue[i].u32Token = 0;
   \   0000002E   0x2100             MOVS     R1,#+0
   \   00000030   0x....             LDR.N    R2,??DataTable8
   \   00000032   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000034   0x230C             MOVS     R3,#+12
   \   00000036   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   0000003A   0x6011             STR      R1,[R2, #+0]
    339              Msg_StatusQueue[i].eState = EMPTY;
   \   0000003C   0x2100             MOVS     R1,#+0
   \   0000003E   0x....             LDR.N    R2,??DataTable8
   \   00000040   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000042   0x230C             MOVS     R3,#+12
   \   00000044   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000048   0x7111             STRB     R1,[R2, #+4]
    340              Msg_StatusQueue[i].u32Timestamp = 0;
   \   0000004A   0x2100             MOVS     R1,#+0
   \   0000004C   0x....             LDR.N    R2,??DataTable8
   \   0000004E   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000050   0x230C             MOVS     R3,#+12
   \   00000052   0xFB03 0x2200      MLA      R2,R3,R0,R2
   \   00000056   0x6091             STR      R1,[R2, #+8]
    341            }
   \   00000058   0x1C40             ADDS     R0,R0,#+1
   \   0000005A   0xE7E5             B.N      ??MessagingInitialize_2
    342          
    343            Msg_pNextStatus = &Msg_StatusQueue[0];
   \                     ??MessagingInitialize_3: (+1)
   \   0000005C   0x....             LDR.N    R0,??DataTable8
   \   0000005E   0x....             LDR.N    R1,??DataTable8_7
   \   00000060   0x6008             STR      R0,[R1, #+0]
    344          
    345            G_u32MessagingFlags = 0;
   \   00000062   0x2000             MOVS     R0,#+0
   \   00000064   0x....             LDR.N    R1,??DataTable8_3
   \   00000066   0x6008             STR      R0,[R1, #+0]
    346            Messaging_pfnStateMachine = MessagingIdle;
   \   00000068   0x.... 0x....      ADR.W    R0,MessagingIdle
   \   0000006C   0x....             LDR.N    R1,??DataTable8_8
   \   0000006E   0x6008             STR      R0,[R1, #+0]
    347          
    348          } /* end MessagingInitialize() */
   \   00000070   0x4770             BX       LR               ;; return
    349          
    350          
    351          /*----------------------------------------------------------------------------------------------------------------------
    352          Function MessagingRunActiveState()
    353          
    354          Description:
    355          Selects and runs one iteration of the current state in the state machine.
    356          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    357          may take 1ms / n to execute.
    358          
    359          Requires:
    360            - State machine function pointer points at current state
    361          
    362          Promises:
    363            - Calls the function to pointed by the state machine function pointer
    364          */

   \                                 In section .text, align 2, keep-with-next
    365          void MessagingRunActiveState(void)
    366          {
   \                     MessagingRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    367            Messaging_pfnStateMachine();
   \   00000002   0x....             LDR.N    R0,??DataTable8_8
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    368          
    369          } /* end MessagingRunActiveState */
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    370          
    371          
    372          /*----------------------------------------------------------------------------------------------------------------------
    373          Function: UpdateMessageStatus()
    374          
    375          Description:
    376          Changes the status of a message in the statue queue.
    377          
    378          Requires:
    379            - u32Token_ is message that should be in the status queue
    380            - eNewState_ is the desired status setting for the message
    381          
    382          Promises:
    383            - eState of the message is set to eNewState_
    384          */

   \                                 In section .text, align 2, keep-with-next
    385          void UpdateMessageStatus(u32 u32Token_, MessageStateType eNewState_)
    386          {
    387            MessageStatus* pListParser = &Msg_StatusQueue[0];
   \                     UpdateMessageStatus: (+1)
   \   00000000   0x....             LDR.N    R2,??DataTable8
    388            
    389            /* Search for the token */
    390            while( (pListParser->u32Token != u32Token_) && (pListParser != &Msg_StatusQueue[STATUS_QUEUE_SIZE]) )
   \                     ??UpdateMessageStatus_0: (+1)
   \   00000002   0x6813             LDR      R3,[R2, #+0]
   \   00000004   0x4283             CMP      R3,R0
   \   00000006   0xD004             BEQ.N    ??UpdateMessageStatus_1
   \   00000008   0x....             LDR.N    R3,??DataTable8_1
   \   0000000A   0x429A             CMP      R2,R3
   \   0000000C   0xD001             BEQ.N    ??UpdateMessageStatus_1
    391            {
    392              pListParser++;
   \   0000000E   0x320C             ADDS     R2,R2,#+12
   \   00000010   0xE7F7             B.N      ??UpdateMessageStatus_0
    393            }
    394          
    395            /* If the token was found, change the status */
    396            if(pListParser != &Msg_StatusQueue[STATUS_QUEUE_SIZE])
   \                     ??UpdateMessageStatus_1: (+1)
   \   00000012   0x....             LDR.N    R3,??DataTable8_1
   \   00000014   0x429A             CMP      R2,R3
   \   00000016   0xD000             BEQ.N    ??UpdateMessageStatus_2
    397            {
    398              pListParser->eState = eNewState_;
   \   00000018   0x7111             STRB     R1,[R2, #+4]
    399            }
    400            
    401          } /* end UpdateMessageStatus() */
   \                     ??UpdateMessageStatus_2: (+1)
   \   0000001A   0x4770             BX       LR               ;; return
    402          
    403          
    404          /*--------------------------------------------------------------------------------------------------------------------*/
    405          /* Private functions */
    406          /*--------------------------------------------------------------------------------------------------------------------*/
    407          
    408          /*----------------------------------------------------------------------------------------------------------------------
    409          Function: AddNewMessageStatus()
    410          
    411          Description:
    412          Adds a new mesage into the status queue.  Due to the tendancy of applications to forget that they wrote
    413          a message here, this buffer is circular and will overwite the oldest message if it needs space for a 
    414          new message.
    415          
    416          Requires:
    417            - u32Token_ is the message of interest
    418          
    419          Promises:
    420            - A new status is created indexed by u32Token_
    421          */

   \                                 In section .text, align 2, keep-with-next
    422          static void AddNewMessageStatus(u32 u32Token_)
    423          {
    424            /* Install the new message message */
    425            Msg_pNextStatus->u32Token = u32Token_;
   \                     AddNewMessageStatus: (+1)
   \   00000000   0x....             LDR.N    R1,??DataTable8_7
   \   00000002   0x6809             LDR      R1,[R1, #+0]
   \   00000004   0x6008             STR      R0,[R1, #+0]
    426            Msg_pNextStatus->eState = WAITING;
   \   00000006   0x2101             MOVS     R1,#+1
   \   00000008   0x....             LDR.N    R2,??DataTable8_7
   \   0000000A   0x6812             LDR      R2,[R2, #+0]
   \   0000000C   0x7111             STRB     R1,[R2, #+4]
    427            Msg_pNextStatus->u32Timestamp = G_u32SystemTime1ms;
   \   0000000E   0x....             LDR.N    R1,??DataTable8_9
   \   00000010   0x6809             LDR      R1,[R1, #+0]
   \   00000012   0x....             LDR.N    R2,??DataTable8_7
   \   00000014   0x6812             LDR      R2,[R2, #+0]
   \   00000016   0x6091             STR      R1,[R2, #+8]
    428            
    429            /* Safely advance the pointer */
    430            Msg_pNextStatus++;
   \   00000018   0x....             LDR.N    R1,??DataTable8_7
   \   0000001A   0x6809             LDR      R1,[R1, #+0]
   \   0000001C   0x310C             ADDS     R1,R1,#+12
   \   0000001E   0x....             LDR.N    R2,??DataTable8_7
   \   00000020   0x6011             STR      R1,[R2, #+0]
    431            if(Msg_pNextStatus == &Msg_StatusQueue[STATUS_QUEUE_SIZE])
   \   00000022   0x....             LDR.N    R1,??DataTable8_7
   \   00000024   0x6809             LDR      R1,[R1, #+0]
   \   00000026   0x....             LDR.N    R2,??DataTable8_1
   \   00000028   0x4291             CMP      R1,R2
   \   0000002A   0xD102             BNE.N    ??AddNewMessageStatus_0
    432            {
    433              Msg_pNextStatus = &Msg_StatusQueue[0];
   \   0000002C   0x....             LDR.N    R1,??DataTable8
   \   0000002E   0x....             LDR.N    R2,??DataTable8_7
   \   00000030   0x6011             STR      R1,[R2, #+0]
    434            }
    435            
    436          } /* end AddNewMessageStatus() */
   \                     ??AddNewMessageStatus_0: (+1)
   \   00000032   0x4770             BX       LR               ;; return
    437          
    438          
    439          /**********************************************************************************************************************
    440          State Machine Function Definitions
    441          **********************************************************************************************************************/
    442          
    443          /*-------------------------------------------------------------------------------------------------------------------*/
    444          /* Do nothing for now */

   \                                 In section .text, align 4, keep-with-next
    445          void MessagingIdle(void)
    446          {
    447            static u32 u32CleaningTime = MSG_STATUS_CLEANING_TIME;
    448            
    449            /* Periodically check for stale messages */
    450            if(--u32CleaningTime == 0)
   \                     MessagingIdle: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable8_10
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x1E40             SUBS     R0,R0,#+1
   \   00000006   0x....             LDR.N    R1,??DataTable8_10
   \   00000008   0x6008             STR      R0,[R1, #+0]
   \   0000000A   0x....             LDR.N    R0,??DataTable8_10
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x2800             CMP      R0,#+0
   \   00000010   0xD103             BNE.N    ??MessagingIdle_0
    451            {
    452              u32CleaningTime = MSG_STATUS_CLEANING_TIME;
   \   00000012   0xF44F 0x707A      MOV      R0,#+1000
   \   00000016   0x....             LDR.N    R1,??DataTable8_10
   \   00000018   0x6008             STR      R0,[R1, #+0]
    453              
    454              /* ??? Probably should add clean of the main message queue to detect any messages that have become stuck */
    455            }
    456              
    457          } /* end MessagingIdle() */
   \                     ??MessagingIdle_0: (+1)
   \   0000001A   0x4770             BX       LR               ;; return

   \                                 In section .data, align 4
   \                     ??u32CleaningTime:
   \   00000000   0x000003E8         DC32 1000
    458          
    459          
    460          /*-------------------------------------------------------------------------------------------------------------------*/
    461          /* Handle an error */

   \                                 In section .text, align 2, keep-with-next
    462          void MessagingError(void)          
    463          {
    464            Messaging_pfnStateMachine = MessagingIdle;
   \                     MessagingError: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable8_11
   \   00000002   0x....             LDR.N    R1,??DataTable8_8
   \   00000004   0x6008             STR      R0,[R1, #+0]
    465            
    466          } /* end MessagingError() */
   \   00000006   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8:
   \   00000000   0x........         DC32     Msg_StatusQueue

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_1:
   \   00000000   0x........         DC32     Msg_StatusQueue+0x300

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_2:
   \   00000000   0x........         DC32     Msg_u8QueuedMessageCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_3:
   \   00000000   0x........         DC32     G_u32MessagingFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_4:
   \   00000000   0x........         DC32     Msg_Pool

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_5:
   \   00000000   0x........         DC32     Msg_u32Token

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_6:
   \   00000000   0x........         DC32     Msg_Pool+0x900

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_7:
   \   00000000   0x........         DC32     Msg_pNextStatus

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_8:
   \   00000000   0x........         DC32     Messaging_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_9:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_10:
   \   00000000   0x........         DC32     ??u32CleaningTime

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable8_11:
   \   00000000   0x........         DC32     MessagingIdle
    467          
    468          
    469          
    470          /*--------------------------------------------------------------------------------------------------------------------*/
    471          /* End of File */
    472          /*--------------------------------------------------------------------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       0   AddNewMessageStatus
       0   DeQueueMessage
       0   MessagingError
       0   MessagingIdle
       0   MessagingInitialize
       8   MessagingRunActiveState
         8   -- Indirect call
       0   QueryMessageStatus
      40   QueueMessage
        40   -> AddNewMessageStatus
       0   UpdateMessageStatus


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_10
       4  ??DataTable8_11
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable8_4
       4  ??DataTable8_5
       4  ??DataTable8_6
       4  ??DataTable8_7
       4  ??DataTable8_8
       4  ??DataTable8_9
      52  AddNewMessageStatus
      86  DeQueueMessage
       4  G_u32MessagingFlags
       8  MessagingError
      28  MessagingIdle
     114  MessagingInitialize
      10  MessagingRunActiveState
       4  Messaging_pfnStateMachine
    2304  Msg_Pool
     768  Msg_StatusQueue
       4  Msg_pNextStatus
       4  Msg_u32Token
       1  Msg_u8QueuedMessageCount
      56  QueryMessageStatus
     250  QueueMessage
      28  UpdateMessageStatus
       4  u32CleaningTime

 
 3 089 bytes in section .bss
     4 bytes in section .data
   680 bytes in section .text
 
   680 bytes of CODE memory
 3 093 bytes of DATA memory

Errors: none
Warnings: none
