###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.2.7424/W32 for ARM        06/May/2017  10:12:19
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpg_common\application\debug.c
#    Command line =  
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpg_common\application\debug.c
#        -D MPGL1 -D MPG1 -D EIE1 --preprocess=cl
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\Debug\List\
#        -lC
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\Debug\List\
#        -o
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\ -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\..\bsp\
#        -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\..\drivers\
#        -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\..\application\
#        -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\
#        -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\application\
#        -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\cmsis\
#        -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\Debug\List\debug.lst
#    Object file  =  
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\Debug\Obj\debug.o
#
###############################################################################

D:\Documents\GitHub\5-5eie\5_course\firmware_mpg_common\application\debug.c
      1          /***********************************************************************************************************************
      2          File: debug.c                                                                
      3          
      4          Description:
      5          Debugging functions and state machine.  Since the system is small, debugger commands
      6          will be strictly numerical, though each command will have a string name that can
      7          be requested by the user.  The debugger will print a list of these commands if 
      8          requested using en+c00.  Commands range from 01 to 99 (must include the leading 0
      9          for single-digit commands) and all commands must have the prefix en+c. 
     10          The current command list can be quickly checked in debug_x.h (where x is application-specific)
     11          
     12          This application requires a UART resource for input/output data.
     13          
     14          The terminal program used to interface to the debugger should be set to:
     15          - no local echo
     16          - send "CR" for new line
     17          - 115200-8-N-1
     18          
     19          
     20          DISCLAIMER: THIS CODE IS PROVIDED WITHOUT ANY WARRANTY OR GUARANTEES.  USERS MAY
     21          USE THIS CODE FOR DEVELOPMENT AND EXAMPLE PURPOSES ONLY.  ENGENUICS TECHNOLOGIES
     22          INCORPORATED IS NOT RESPONSIBLE FOR ANY ERRORS, OMISSIONS, OR DAMAGES THAT COULD
     23          RESULT FROM USING THIS FIRMWARE IN WHOLE OR IN PART.
     24          
     25          ------------------------------------------------------------------------------------------------------------------------
     26          API:
     27          Types: none
     28          
     29          Globals:
     30          G_au8DebugScanfBuffer[] is the DebugScanf() input buffer that can be read directly
     31          G_u8DebugScanfCharCount holds number of characters in Debug_au8ScanfBuffer
     32          Both of these variables are cleared whenever DebugScanf() is called.
     33          
     34          Constants:
     35          DEBUG_SCANF_BUFFER_SIZE is the size of G_au8DebugScanfBuffer and thus the max of G_u8DebugScanfCharCount
     36          
     37          Public:
     38          u32 DebugPrintf(u8* u8String_)
     39          Queues the string pointed to by u8String_ to the Debug port.  The string must be
     40          null-terminated.  It may also contain control charactesr like newline (\n) and line feed (\f)
     41          e.g.
     42          u8 u8String[] = "A string to print.\n\r"
     43          DebugPrintf(u8String);
     44          
     45          void DebugLineFeed(void)
     46          Queues a <CR><LF> sequence to the debug UART.
     47          e.g.
     48          DebugLineFeed();
     49          
     50          void DebugPrintNumber(u32 u32Number_)
     51          Formats a long into an ASCII string and queues to print.  Leading zeros are not printed.
     52          e.g.
     53          u32 u32Number = 1234567;
     54          DebugPrintNumber(u32Number);
     55          
     56          u8 DebugScanf(u8* au8Buffer_)
     57          Copies the current input buffer to au8Buffer_ and returns the number of new characters.
     58          Everytime DebugScanf is called, the 
     59          e.g.
     60          u8 u8MyBuffer[SCANF_BUFFER_SIZE]
     61          u8 u8NumChars;
     62          u8NumChars = DebugScanf(u8MyBuffer);
     63          
     64          ***********************************************************************************************************************/
     65          
     66          #include "configuration.h"
     67          
     68          /***********************************************************************************************************************
     69          Global variable definitions with scope across entire project.
     70          All Global variable names shall start with "G_Debug"
     71          ***********************************************************************************************************************/
     72          /* New variables */

   \                                 In section .bss, align 4
     73          u32 G_u32DebugFlags;                                     /* Debug flag register */
   \                     G_u32DebugFlags:
   \   00000000                      DS8 4
     74          

   \                                 In section .bss, align 4
     75          u8 G_au8DebugScanfBuffer[DEBUG_SCANF_BUFFER_SIZE]; /* Space to latch characters for DebugScanf() */
   \                     G_au8DebugScanfBuffer:
   \   00000000                      DS8 128

   \                                 In section .bss, align 1
     76          u8 G_u8DebugScanfCharCount = 0;                    /* Counter for # of characters in Debug_au8ScanfBuffer */
   \                     G_u8DebugScanfCharCount:
   \   00000000                      DS8 1
     77          
     78          
     79          /*--------------------------------------------------------------------------------------------------------------------*/
     80          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     81          extern volatile u32 G_u32SystemFlags;                    /* From main.c */
     82          extern volatile u32 G_u32ApplicationFlags;               /* From main.c */
     83          
     84          extern volatile u32 G_u32SystemTime1ms;                  /* From board-specific source file */
     85          extern volatile u32 G_u32SystemTime1s;                   /* From board-specific source file */
     86          
     87          extern u8 G_au8MessageOK[];                              /* From utilities.c */
     88          extern u8 G_au8MessageFAIL[];                            /* From utilities.c */
     89          extern u8 G_au8MessageON[];                              /* From utilities.c */
     90          extern u8 G_au8MessageOFF[];                             /* From utilities.c */
     91          
     92          
     93          /***********************************************************************************************************************
     94          Global variable definitions with scope limited to this local application.
     95          Variable names shall start with "Debug_" and be declared as static.
     96          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     97          static fnCode_type Debug_pfnStateMachine;                /* The Debug state machine function pointer */
   \                     Debug_pfnStateMachine:
   \   00000000                      DS8 4
     98          

   \                                 In section .bss, align 4
     99          static UartPeripheralType* Debug_Uart;                   /* Pointer to debug UART peripheral object */
   \                     Debug_Uart:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    100          static u32 Debug_u32CurrentMessageToken;                 /* Token for current message */
   \                     Debug_u32CurrentMessageToken:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
    101          static u8 Debug_u8ErrorCode;                             /* Error code */
   \                     Debug_u8ErrorCode:
   \   00000000                      DS8 1
    102          

   \                                 In section .bss, align 4
    103          static u8 Debug_au8RxBuffer[DEBUG_RX_BUFFER_SIZE];       /* Space for incoming characters of debug commands */
   \                     Debug_au8RxBuffer:
   \   00000000                      DS8 128

   \                                 In section .bss, align 4
    104          static u8 *Debug_pu8RxBufferNextChar;                    /* Pointer to next spot in the Rxbuffer */
   \                     Debug_pu8RxBufferNextChar:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    105          static u8 *Debug_pu8RxBufferParser;                      /* Pointer to loop through the Rx buffer */
   \                     Debug_pu8RxBufferParser:
   \   00000000                      DS8 4
    106          

   \                                 In section .bss, align 4
    107          static u8 Debug_au8CommandBuffer[DEBUG_CMD_BUFFER_SIZE]; /* Space to store chars as they build up to the next command */ 
   \                     Debug_au8CommandBuffer:
   \   00000000                      DS8 64

   \                                 In section .bss, align 4
    108          static u8 *Debug_pu8CmdBufferNextChar;                   /* Pointer to incoming char location in the command buffer */
   \                     Debug_pu8CmdBufferNextChar:
   \   00000000                      DS8 4

   \                                 In section .bss, align 2
    109          static u16 Debug_u16CommandSize;                         /* Number of characters in the command buffer */
   \                     Debug_u16CommandSize:
   \   00000000                      DS8 2
    110          

   \                                 In section .bss, align 1
    111          static u8 Debug_u8Command;                               /* A validated command number */
   \                     Debug_u8Command:
   \   00000000                      DS8 1
    112          
    113          /* Add commands by updating debug.h in the Command-Specific Definitions section, then update this list
    114          with the function name to call for the corresponding command: */
    115          #ifdef MPGL1

   \                                 In section .data, align 4
    116          DebugCommandType Debug_au8Commands[DEBUG_COMMANDS] = { {DEBUG_CMD_NAME00, DebugCommandPrepareList},
   \                     Debug_au8Commands:
   \   00000000   0x........         DC32 ?_0, DebugCommandPrepareList, ?_1, DebugCommandLedTestToggle, ?_2
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000014   0x........         DC32 DebugCommandSysTimeToggle, ?_3, DebugCommandDummy, ?_4
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000024   0x........         DC32 DebugCommandDummy, ?_5, DebugCommandDummy, ?_6, DebugCommandDummy
   \              0x........   
   \              0x........   
   \              0x........   
   \              0x........   
   \   00000038   0x........         DC32 ?_7, DebugCommandDummy
   \              0x........   
    117                                                                 {DEBUG_CMD_NAME01, DebugCommandLedTestToggle},
    118                                                                 {DEBUG_CMD_NAME02, DebugCommandSysTimeToggle},
    119                                                                 {DEBUG_CMD_NAME03, DebugCommandDummy},
    120                                                                 {DEBUG_CMD_NAME04, DebugCommandDummy},
    121                                                                 {DEBUG_CMD_NAME05, DebugCommandDummy},
    122                                                                 {DEBUG_CMD_NAME06, DebugCommandDummy},
    123                                                                 {DEBUG_CMD_NAME07, DebugCommandDummy} 
    124                                                               };
    125          

   \                                 In section .data, align 4
    126          static u8 Debug_au8StartupMsg[] = "\n\n\r*** RAZOR SAM3U2 ASCII LCD DEVELOPMENT BOARD ***\n\rDebug ready\n\r";
   \                     Debug_au8StartupMsg:
   \   00000000   0x0A 0x0A          DC8 0AH, 0AH, 0DH, 2AH, 2AH, 2AH, 20H, 52H
   \              0x0D 0x2A    
   \              0x2A 0x2A    
   \              0x20 0x52    
   \   00000008   0x41 0x5A          DC8 41H, 5AH, 4FH, 52H, 20H, 53H, 41H, 4DH
   \              0x4F 0x52    
   \              0x20 0x53    
   \              0x41 0x4D    
   \   00000010   0x33 0x55          DC8 33H, 55H, 32H, 20H, 41H, 53H, 43H, 49H
   \              0x32 0x20    
   \              0x41 0x53    
   \              0x43 0x49    
   \   00000018   0x49 0x20          DC8 49H, 20H, 4CH, 43H, 44H, 20H, 44H, 45H
   \              0x4C 0x43    
   \              0x44 0x20    
   \              0x44 0x45    
   \   00000020   0x56 0x45          DC8 56H, 45H, 4CH, 4FH, 50H, 4DH, 45H, 4EH
   \              0x4C 0x4F    
   \              0x50 0x4D    
   \              0x45 0x4E    
   \   00000028   0x54 0x20          DC8 54H, 20H, 42H, 4FH, 41H, 52H, 44H, 20H
   \              0x42 0x4F    
   \              0x41 0x52    
   \              0x44 0x20    
   \   00000030   0x2A 0x2A          DC8 2AH, 2AH, 2AH, 0AH, 0DH, 44H, 65H, 62H
   \              0x2A 0x0A    
   \              0x0D 0x44    
   \              0x65 0x62    
   \   00000038   0x75 0x67          DC8 75H, 67H, 20H, 72H, 65H, 61H, 64H, 79H
   \              0x20 0x72    
   \              0x65 0x61    
   \              0x64 0x79    
   \   00000040   0x0A 0x0D          DC8 0AH, 0DH, 0
   \              0x00         
   \   00000043   0x00               DC8 0
    127          #endif /* MPGL1 */
    128          
    129          #ifdef MPGL2
    130          DebugCommandType Debug_au8Commands[DEBUG_COMMANDS] = { {DEBUG_CMD_NAME00, DebugCommandPrepareList},
    131                                                                 {DEBUG_CMD_NAME01, DebugCommandLedTestToggle},
    132                                                                 {DEBUG_CMD_NAME02, DebugCommandSysTimeToggle},
    133                                                                 {DEBUG_CMD_NAME03, DebugCommandCaptouchValuesToggle},
    134                                                                 {DEBUG_CMD_NAME04, DebugCommandDummy},
    135                                                                 {DEBUG_CMD_NAME05, DebugCommandDummy},
    136                                                                 {DEBUG_CMD_NAME06, DebugCommandDummy},
    137                                                                 {DEBUG_CMD_NAME07, DebugCommandDummy} 
    138                                                               };
    139          
    140          static u8 Debug_au8StartupMsg[] = "\n\n\r*** RAZOR SAM3U2 DOT MATRIX DEVELOPMENT BOARD ***\n\rDebug ready\n\r";
    141          #endif /* MPGL2 */
    142          
    143          
    144          /***********************************************************************************************************************
    145          * Function Definitions
    146          ***********************************************************************************************************************/
    147          
    148          /*--------------------------------------------------------------------------------------------------------------------*/
    149          /* Public Functions */
    150          /*--------------------------------------------------------------------------------------------------------------------*/
    151          
    152          /*----------------------------------------------------------------------------------------------------------------------
    153          Function: DebugPrintf
    154          
    155          Description:
    156          Sends a text string to the debug UART.
    157          
    158          Requires:
    159            - u8String_ is a NULL-terminated C-string
    160            - The debug UART resource has been setup for the debug application.
    161          
    162          Promises:
    163            - The string is queued to the debug UART.
    164            - The message token is returned
    165          */

   \                                 In section .text, align 2, keep-with-next
    166          u32 DebugPrintf(u8* u8String_)
    167          {
   \                     DebugPrintf: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
    168            u8* pu8Parser = u8String_;
   \   00000004   0x0025             MOVS     R5,R4
    169            u32 u32Size = 0;
   \   00000006   0x2600             MOVS     R6,#+0
    170            
    171            while(*pu8Parser != NULL)
   \                     ??DebugPrintf_0: (+1)
   \   00000008   0x7828             LDRB     R0,[R5, #+0]
   \   0000000A   0x2800             CMP      R0,#+0
   \   0000000C   0xD002             BEQ.N    ??DebugPrintf_1
    172            {
    173              u32Size++;
   \   0000000E   0x1C76             ADDS     R6,R6,#+1
    174              pu8Parser++;
   \   00000010   0x1C6D             ADDS     R5,R5,#+1
   \   00000012   0xE7F9             B.N      ??DebugPrintf_0
    175            }
    176            return( UartWriteData(Debug_Uart, u32Size, u8String_) );
   \                     ??DebugPrintf_1: (+1)
   \   00000014   0x0022             MOVS     R2,R4
   \   00000016   0x0031             MOVS     R1,R6
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable17
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x.... 0x....      BL       UartWriteData
   \   00000022   0xBD70             POP      {R4-R6,PC}       ;; return
    177           
    178          } /* end DebugPrintf() */
    179          
    180          
    181          /*----------------------------------------------------------------------------------------------------------------------
    182          Function: DebugLineFeed
    183          
    184          Description:
    185          Queues a <CR><LF> sequence to the debug UART.
    186          
    187          Requires:
    188            -
    189          
    190          Promises:
    191            - <CR><LF> sequence to the debug UART
    192          */

   \                                 In section .text, align 2, keep-with-next
    193          void DebugLineFeed(void)
    194          {
   \                     DebugLineFeed: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    195            u8 au8Linefeed[] = {ASCII_LINEFEED, ASCII_CARRIAGE_RETURN};
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable17_1
   \   00000006   0x8800             LDRH     R0,[R0, #+0]
   \   00000008   0xF8AD 0x0000      STRH     R0,[SP, #+0]
    196            
    197            UartWriteData(Debug_Uart, sizeof(au8Linefeed), &au8Linefeed[0]);
   \   0000000C   0xAA00             ADD      R2,SP,#+0
   \   0000000E   0x2102             MOVS     R1,#+2
   \   00000010   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000014   0x6800             LDR      R0,[R0, #+0]
   \   00000016   0x.... 0x....      BL       UartWriteData
    198          
    199          } /* end DebugLineFeed() */
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
    200          
    201          
    202          /*-----------------------------------------------------------------------------/
    203          Function: DebugPrintNumber
    204          
    205          Description:
    206          Formats a long into an ASCII string and queues to print
    207          
    208          Requires:
    209            - Enough space is available on the heap to temporarily store the number array
    210          
    211          Promises:
    212            - The number is converted to an array of ascii without leading zeros and sent to UART
    213          */

   \                                 In section .text, align 2, keep-with-next
    214          void DebugPrintNumber(u32 u32Number_)
    215          {
   \                     DebugPrintNumber: (+1)
   \   00000000   0xE92D 0x43FE      PUSH     {R1-R9,LR}
   \   00000004   0x0004             MOVS     R4,R0
    216            bool bFoundDigit = FALSE;
   \   00000006   0x2500             MOVS     R5,#+0
    217            u8 au8AsciiNumber[10];
    218            u8 u8CharCount = 0;
   \   00000008   0x2600             MOVS     R6,#+0
    219            u32 u32Temp, u32Divider = 1000000000;
   \   0000000A   0x.... 0x....      LDR.W    R8,??DataTable17_2  ;; 0x3b9aca00
    220            u8 *pu8Data;
    221          
    222            /* Parse out all the digits, start counting after leading zeros */
    223            for(u8 index = 0; index < 10; index++)
   \   0000000E   0x2000             MOVS     R0,#+0
   \                     ??DebugPrintNumber_0: (+1)
   \   00000010   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000012   0x280A             CMP      R0,#+10
   \   00000014   0xDA19             BGE.N    ??DebugPrintNumber_1
    224            {
    225              au8AsciiNumber[index] = (u32Number_ / u32Divider) + 0x30;
   \   00000016   0xFBB4 0xF1F8      UDIV     R1,R4,R8
   \   0000001A   0x3130             ADDS     R1,R1,#+48
   \   0000001C   0xAA00             ADD      R2,SP,#+0
   \   0000001E   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000020   0x5481             STRB     R1,[R0, R2]
    226              if(au8AsciiNumber[index] != '0')
   \   00000022   0xA900             ADD      R1,SP,#+0
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x5C41             LDRB     R1,[R0, R1]
   \   00000028   0x2930             CMP      R1,#+48
   \   0000002A   0xD001             BEQ.N    ??DebugPrintNumber_2
    227              {
    228                bFoundDigit = TRUE;
   \   0000002C   0x2101             MOVS     R1,#+1
   \   0000002E   0x000D             MOVS     R5,R1
    229              }
    230              if(bFoundDigit)
   \                     ??DebugPrintNumber_2: (+1)
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x2D00             CMP      R5,#+0
   \   00000034   0xD000             BEQ.N    ??DebugPrintNumber_3
    231              {
    232                u8CharCount++;
   \   00000036   0x1C76             ADDS     R6,R6,#+1
    233              }
    234              u32Number_ %= u32Divider;
   \                     ??DebugPrintNumber_3: (+1)
   \   00000038   0xFBB4 0xF1F8      UDIV     R1,R4,R8
   \   0000003C   0xFB08 0x4411      MLS      R4,R8,R1,R4
    235              u32Divider /= 10;
   \   00000040   0x210A             MOVS     R1,#+10
   \   00000042   0xFBB8 0xF8F1      UDIV     R8,R8,R1
    236            }
   \   00000046   0x1C40             ADDS     R0,R0,#+1
   \   00000048   0xE7E2             B.N      ??DebugPrintNumber_0
    237            
    238            /* Handle special case where u32Number == 0 */
    239            if(!bFoundDigit)
   \                     ??DebugPrintNumber_1: (+1)
   \   0000004A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000004C   0x2D00             CMP      R5,#+0
   \   0000004E   0xD101             BNE.N    ??DebugPrintNumber_4
    240            {
    241              u8CharCount = 1;
   \   00000050   0x2001             MOVS     R0,#+1
   \   00000052   0x0006             MOVS     R6,R0
    242            }
    243            
    244            /* Allocate memory for the right number and copy the array */
    245            pu8Data = malloc(u8CharCount);
   \                     ??DebugPrintNumber_4: (+1)
   \   00000054   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000056   0x0030             MOVS     R0,R6
   \   00000058   0x.... 0x....      BL       malloc
   \   0000005C   0x4681             MOV      R9,R0
    246            if (pu8Data == NULL)
   \   0000005E   0xF1B9 0x0F00      CMP      R9,#+0
   \   00000062   0xD108             BNE.N    ??DebugPrintNumber_5
    247            {
    248              Debug_u8ErrorCode = DEBUG_ERROR_MALLOC;
   \   00000064   0x2002             MOVS     R0,#+2
   \   00000066   0x.... 0x....      LDR.W    R1,??DataTable17_3
   \   0000006A   0x7008             STRB     R0,[R1, #+0]
    249              Debug_pfnStateMachine = DebugSM_Error;
   \   0000006C   0x.... 0x....      ADR.W    R0,DebugSM_Error
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable17_4
   \   00000074   0x6008             STR      R0,[R1, #+0]
    250            }
    251            
    252            u32Temp = 9;
   \                     ??DebugPrintNumber_5: (+1)
   \   00000076   0x2009             MOVS     R0,#+9
   \   00000078   0x0007             MOVS     R7,R0
    253            for(u8 index = u8CharCount; index != 0; index--)
   \   0000007A   0x0030             MOVS     R0,R6
   \                     ??DebugPrintNumber_6: (+1)
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007E   0x2800             CMP      R0,#+0
   \   00000080   0xD009             BEQ.N    ??DebugPrintNumber_7
    254            {
    255              pu8Data[index - 1] = au8AsciiNumber[u32Temp--];
   \   00000082   0xA900             ADD      R1,SP,#+0
   \   00000084   0x5C79             LDRB     R1,[R7, R1]
   \   00000086   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000088   0xEB10 0x0209      ADDS     R2,R0,R9
   \   0000008C   0xF802 0x1C01      STRB     R1,[R2, #-1]
   \   00000090   0x1E7F             SUBS     R7,R7,#+1
    256            }
   \   00000092   0x1E40             SUBS     R0,R0,#+1
   \   00000094   0xE7F2             B.N      ??DebugPrintNumber_6
    257              
    258            /* Print the ascii string and free the memory */
    259            UartWriteData(Debug_Uart, u8CharCount, pu8Data);
   \                     ??DebugPrintNumber_7: (+1)
   \   00000096   0x464A             MOV      R2,R9
   \   00000098   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000009A   0x0031             MOVS     R1,R6
   \   0000009C   0x.... 0x....      LDR.W    R0,??DataTable17
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0x.... 0x....      BL       UartWriteData
    260            free(pu8Data);
   \   000000A6   0x4648             MOV      R0,R9
   \   000000A8   0x.... 0x....      BL       free
    261            
    262          } /* end DebugDebugPrintNumber() */
   \   000000AC   0xE8BD 0x83F7      POP      {R0-R2,R4-R9,PC}  ;; return
    263          
    264          
    265          /*----------------------------------------------------------------------------------------------------------------------
    266          Function: DebugScanf
    267          
    268          Description:
    269          Copies G_u8DebugScanfCharCount characters from G_au8DebugScanfBuffer to a target array 
    270          so the input can be saved.  Once copied, G_au8DebugScanfBuffer is cleared and
    271          G_u8DebugScanfCharCount is zeroed.
    272          
    273          Requires:
    274            - G_u8DebugScanfCharCount holds the number of characters in the G_au8DebugScanfBuffer
    275            - au8Buffer_ points to an array large enough to hold G_u8DebugScanfCharCount characters
    276            - Debug task is blocked here so new characters are not added
    277          
    278          Promises:
    279            - G_u8DebugScanfCharCount characters copied to *au8Buffer_
    280            - G_au8DebugScanfBuffer[i] = '\0', where 0 <= i <= DEBUG_SCANF_BUFFER_SIZE
    281            - G_u8DebugScanfCharCount = 0
    282          */

   \                                 In section .text, align 2, keep-with-next
    283          u8 DebugScanf(u8* au8Buffer_)
    284          {
   \                     DebugScanf: (+1)
   \   00000000   0xB410             PUSH     {R4}
   \   00000002   0x0001             MOVS     R1,R0
    285            u8 u8Temp = G_u8DebugScanfCharCount;
   \   00000004   0x.... 0x....      LDR.W    R0,??DataTable17_5
   \   00000008   0x7800             LDRB     R0,[R0, #+0]
    286            
    287            /* Copy the characters, clearing as we go */
    288            for(u8 i = 0; i < G_u8DebugScanfCharCount; i++)
   \   0000000A   0x2200             MOVS     R2,#+0
   \                     ??DebugScanf_0: (+1)
   \   0000000C   0x.... 0x....      LDR.W    R3,??DataTable17_5
   \   00000010   0x781B             LDRB     R3,[R3, #+0]
   \   00000012   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000014   0x429A             CMP      R2,R3
   \   00000016   0xD20C             BCS.N    ??DebugScanf_1
    289            {
    290              *(au8Buffer_ + i) = G_au8DebugScanfBuffer[i];
   \   00000018   0x.... 0x....      LDR.W    R3,??DataTable17_6
   \   0000001C   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000001E   0x5CD3             LDRB     R3,[R2, R3]
   \   00000020   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   00000022   0x5453             STRB     R3,[R2, R1]
    291              G_au8DebugScanfBuffer[i] = '\0';
   \   00000024   0x2300             MOVS     R3,#+0
   \   00000026   0x.... 0x....      LDR.W    R4,??DataTable17_6
   \   0000002A   0xB2D2             UXTB     R2,R2            ;; ZeroExt  R2,R2,#+24,#+24
   \   0000002C   0x5513             STRB     R3,[R2, R4]
    292            }
   \   0000002E   0x1C52             ADDS     R2,R2,#+1
   \   00000030   0xE7EC             B.N      ??DebugScanf_0
    293            
    294            G_u8DebugScanfCharCount = 0;
   \                     ??DebugScanf_1: (+1)
   \   00000032   0x2200             MOVS     R2,#+0
   \   00000034   0x.... 0x....      LDR.W    R3,??DataTable17_5
   \   00000038   0x701A             STRB     R2,[R3, #+0]
    295            return u8Temp;
   \   0000003A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003C   0xBC10             POP      {R4}
   \   0000003E   0x4770             BX       LR               ;; return
    296            
    297          } /* end DebugScanf() */
    298          
    299          
    300          
    301          /*----------------------------------------------------------------------------------------------------------------------
    302          Function: DebugSetPassthrough
    303          
    304          Description:
    305          Puts the Debug task in Passthrough mode so ALL characters received are put in to the Scanf buffer and
    306          the Debug task does not look for input for the menu system. This allows task to have full access to 
    307          terminal input without the Debug task printing messages or stealing Backspace characters!
    308          
    309          Passthrough mode does NOT disable any other Debug functions that have already been enabled.  For example,
    310          if you want the 1ms timing violation warning you can enable this and then enable Passthrough mode.
    311          
    312          Requires:
    313            -
    314          
    315          Promises:
    316            - G_u32DebugFlags _DEBUG_PASSTHROUGH is set
    317          */

   \                                 In section .text, align 2, keep-with-next
    318          void DebugSetPassthrough(void)
    319          {
   \                     DebugSetPassthrough: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    320            G_u32DebugFlags |= _DEBUG_PASSTHROUGH;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable17_7
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable17_7
   \   00000010   0x6008             STR      R0,[R1, #+0]
    321            
    322            DebugPrintf("\n\n\r***Debug Passthrough enabled***\n\n\r");
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable17_8
   \   00000016   0x.... 0x....      BL       DebugPrintf
    323          
    324          } /* end DebugSetPassthrough */
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
    325          
    326          
    327          /*----------------------------------------------------------------------------------------------------------------------
    328          Function: DebugClearPassthrough
    329          
    330          Description:
    331          Takes the Debug task out of Passthrough mode.
    332          
    333          Requires:
    334            -
    335          
    336          Promises:
    337            - G_u32DebugFlags _DEBUG_PASSTHROUGH is cleared
    338          */

   \                                 In section .text, align 2, keep-with-next
    339          void DebugClearPassthrough(void)
    340          {
   \                     DebugClearPassthrough: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    341            G_u32DebugFlags &= ~_DEBUG_PASSTHROUGH;
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable17_7
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0xF030 0x0004      BICS     R0,R0,#0x4
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable17_7
   \   00000010   0x6008             STR      R0,[R1, #+0]
    342            
    343            DebugPrintf("\n\n\r***Debug Passthrough disabled***\n\n\r");
   \   00000012   0x.... 0x....      LDR.W    R0,??DataTable17_9
   \   00000016   0x.... 0x....      BL       DebugPrintf
    344            
    345          } /* end DebugClearPassthrough */
   \   0000001A   0xBD01             POP      {R0,PC}          ;; return
    346          
    347          
    348          /*----------------------------------------------------------------------------------------------------------------------
    349          Function: SystemStatusReport
    350          
    351          Description:
    352          Reports if system is good or not.
    353          
    354          Requires:
    355            - G_u32SystemFlags up to date with system status
    356            - New tasks should be added to the check list below including in the message string for the task name
    357            - The system is in initialization state so MsgSenderForceSend() is used
    358              to output each meassage after it is queued.
    359          
    360          Promises:
    361            - Prints out messages for any system tests that failed
    362            - Prints out overall good message if all tests passed
    363          */

   \                                 In section .text, align 2, keep-with-next
    364          void SystemStatusReport(void)
    365          {
   \                     SystemStatusReport: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB0AC             SUB      SP,SP,#+176
    366            u8 au8SystemPassed[] = "No failed tasks.";
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable17_10
   \   0000000A   0x2211             MOVS     R2,#+17
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy
    367            u8 au8SystemReady[] = "\n\rInitialization complete. Type en+c00 for debug menu.  Failed tasks:\n\r";
   \   00000010   0xA819             ADD      R0,SP,#+100
   \   00000012   0x.... 0x....      LDR.W    R1,??DataTable17_11
   \   00000016   0x2248             MOVS     R2,#+72
   \   00000018   0x.... 0x....      BL       __aeabi_memcpy4
    368            u32 u32TaskFlagMaskBit = (u32)0x01;
   \   0000001C   0x2401             MOVS     R4,#+1
    369            bool bNoFailedTasks = TRUE;
   \   0000001E   0x2501             MOVS     R5,#+1
    370          
    371          #ifdef MPGL1
    372            u8 aau8AppShortNames[NUMBER_APPLICATIONS][MAX_TASK_NAME_SIZE] = {"LED", "BUTTON", "DEBUG", "LCD", "ANT", "TIMER", "SD"};
   \   00000020   0xA805             ADD      R0,SP,#+20
   \   00000022   0x.... 0x....      LDR.W    R1,??DataTable17_12
   \   00000026   0x2250             MOVS     R2,#+80
   \   00000028   0x.... 0x....      BL       __aeabi_memcpy4
    373          #endif /* MPGL1 */
    374          
    375          #ifdef MPGL2
    376            u8 aau8AppShortNames[NUMBER_APPLICATIONS][MAX_TASK_NAME_SIZE] = {"LED", "BUTTON", "DEBUG", "LCD", "ANT", "TIMER", "CAPTOUCH"};
    377          #endif /* MPGL2 */
    378          
    379            /* Announce init complete then report any tasks that failed init */
    380            DebugPrintf(au8SystemReady);
   \   0000002C   0xA819             ADD      R0,SP,#+100
   \   0000002E   0x.... 0x....      BL       DebugPrintf
    381              
    382            for(u8 i = 0; i < NUMBER_APPLICATIONS; i++)
   \   00000032   0x2600             MOVS     R6,#+0
   \                     ??SystemStatusReport_0: (+1)
   \   00000034   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000036   0x2E08             CMP      R6,#+8
   \   00000038   0xDA12             BGE.N    ??SystemStatusReport_1
    383            {
    384              if( !(u32TaskFlagMaskBit & G_u32ApplicationFlags) )
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable17_13
   \   0000003E   0x6800             LDR      R0,[R0, #+0]
   \   00000040   0x4204             TST      R4,R0
   \   00000042   0xD10A             BNE.N    ??SystemStatusReport_2
    385              {
    386                bNoFailedTasks = FALSE;
   \   00000044   0x2000             MOVS     R0,#+0
   \   00000046   0x0005             MOVS     R5,R0
    387                DebugPrintf(&aau8AppShortNames[i][0]);
   \   00000048   0xA805             ADD      R0,SP,#+20
   \   0000004A   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   0000004C   0x210A             MOVS     R1,#+10
   \   0000004E   0xFB01 0x0006      MLA      R0,R1,R6,R0
   \   00000052   0x.... 0x....      BL       DebugPrintf
    388                DebugLineFeed();
   \   00000056   0x.... 0x....      BL       DebugLineFeed
    389              }
    390              
    391              u32TaskFlagMaskBit <<= 1;
   \                     ??SystemStatusReport_2: (+1)
   \   0000005A   0x0064             LSLS     R4,R4,#+1
    392            }     
   \   0000005C   0x1C76             ADDS     R6,R6,#+1
   \   0000005E   0xE7E9             B.N      ??SystemStatusReport_0
    393                  
    394            if( bNoFailedTasks)
   \                     ??SystemStatusReport_1: (+1)
   \   00000060   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000062   0x2D00             CMP      R5,#+0
   \   00000064   0xD002             BEQ.N    ??SystemStatusReport_3
    395            {
    396              DebugPrintf(au8SystemPassed);
   \   00000066   0xA800             ADD      R0,SP,#+0
   \   00000068   0x.... 0x....      BL       DebugPrintf
    397            }
    398            
    399            DebugLineFeed();
   \                     ??SystemStatusReport_3: (+1)
   \   0000006C   0x.... 0x....      BL       DebugLineFeed
    400            
    401          } /* end SystemStatusReport() */
   \   00000070   0xB02C             ADD      SP,SP,#+176
   \   00000072   0xBD70             POP      {R4-R6,PC}       ;; return
    402          
    403          
    404          /*--------------------------------------------------------------------------------------------------------------------*/
    405          /* Protected Functions */
    406          /*--------------------------------------------------------------------------------------------------------------------*/
    407          
    408          /*----------------------------------------------------------------------------------------------------------------------
    409          Function: DebugInitialize
    410          
    411          Description:
    412          Sets up the debug command list and activates the debug functionality.
    413          
    414          Requires:
    415            - The debug application is not yet running
    416            - The UART resource requested should be free
    417          
    418          Promises:
    419            - UART resource Debug_au8RxBuffer initialized to all 0
    420            - Buffer pointers Debug_pu8CmdBufferCurrentChar and Debug_pu8RxBufferParser set to the start of the buffer
    421            - Debug_pfnStateMachine set to Idle
    422          */

   \                                 In section .text, align 2, keep-with-next
    423          void DebugInitialize(void)
    424          {
   \                     DebugInitialize: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB085             SUB      SP,SP,#+20
    425            UartConfigurationType sUartConfig;  
    426          
    427            /* Clear the receive buffer */
    428            for (u16 i = 0; i < DEBUG_RX_BUFFER_SIZE; i++)
   \   00000004   0x2000             MOVS     R0,#+0
   \                     ??DebugInitialize_0: (+1)
   \   00000006   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000008   0x2880             CMP      R0,#+128
   \   0000000A   0xD206             BCS.N    ??DebugInitialize_1
    429            {
    430              Debug_au8RxBuffer[i] = 0;
   \   0000000C   0x2100             MOVS     R1,#+0
   \   0000000E   0x.... 0x....      LDR.W    R2,??DataTable17_14
   \   00000012   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   00000014   0x5481             STRB     R1,[R0, R2]
    431            }
   \   00000016   0x1C40             ADDS     R0,R0,#+1
   \   00000018   0xE7F5             B.N      ??DebugInitialize_0
    432          
    433            /* Clear the scanf buffer and counter */
    434            G_u8DebugScanfCharCount = 0;
   \                     ??DebugInitialize_1: (+1)
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable17_5
   \   00000020   0x7008             STRB     R0,[R1, #+0]
    435            for (u8 i = 0; i < DEBUG_SCANF_BUFFER_SIZE; i++)
   \   00000022   0x2000             MOVS     R0,#+0
   \                     ??DebugInitialize_2: (+1)
   \   00000024   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000026   0x2880             CMP      R0,#+128
   \   00000028   0xDA06             BGE.N    ??DebugInitialize_3
    436            {
    437              G_au8DebugScanfBuffer[i] = 0;
   \   0000002A   0x2100             MOVS     R1,#+0
   \   0000002C   0x.... 0x....      LDR.W    R2,??DataTable17_6
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x5481             STRB     R1,[R0, R2]
    438            }
   \   00000034   0x1C40             ADDS     R0,R0,#+1
   \   00000036   0xE7F5             B.N      ??DebugInitialize_2
    439          
    440            /* Initailze startup values and the command array */
    441            Debug_pu8RxBufferParser    = &Debug_au8RxBuffer[0];
   \                     ??DebugInitialize_3: (+1)
   \   00000038   0x.... 0x....      LDR.W    R0,??DataTable17_14
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable17_15
   \   00000040   0x6008             STR      R0,[R1, #+0]
    442            Debug_pu8RxBufferNextChar  = &Debug_au8RxBuffer[0]; 
   \   00000042   0x.... 0x....      LDR.W    R0,??DataTable17_14
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable17_16
   \   0000004A   0x6008             STR      R0,[R1, #+0]
    443            Debug_pu8CmdBufferNextChar = &Debug_au8CommandBuffer[0]; 
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable17_17
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable17_18
   \   00000054   0x6008             STR      R0,[R1, #+0]
    444          
    445            /* Request the UART resource to be used for the Debug application */
    446            sUartConfig.UartPeripheral     = DEBUG_UART;
   \   00000056   0x2002             MOVS     R0,#+2
   \   00000058   0xF88D 0x0000      STRB     R0,[SP, #+0]
    447            sUartConfig.pu8RxBufferAddress = &Debug_au8RxBuffer[0];
   \   0000005C   0x.... 0x....      LDR.W    R0,??DataTable17_14
   \   00000060   0x9001             STR      R0,[SP, #+4]
    448            sUartConfig.pu8RxNextByte      = &Debug_pu8RxBufferNextChar;
   \   00000062   0x.... 0x....      LDR.W    R0,??DataTable17_16
   \   00000066   0x9002             STR      R0,[SP, #+8]
    449            sUartConfig.u16RxBufferSize    = DEBUG_RX_BUFFER_SIZE;
   \   00000068   0x2080             MOVS     R0,#+128
   \   0000006A   0xF8AD 0x0002      STRH     R0,[SP, #+2]
    450            sUartConfig.fnRxCallback       = DebugRxCallback;
   \   0000006E   0x.... 0x....      ADR.W    R0,DebugRxCallback
   \   00000072   0x9003             STR      R0,[SP, #+12]
    451            
    452            Debug_Uart = UartRequest(&sUartConfig);
   \   00000074   0xA800             ADD      R0,SP,#+0
   \   00000076   0x.... 0x....      BL       UartRequest
   \   0000007A   0x.... 0x....      LDR.W    R1,??DataTable17
   \   0000007E   0x6008             STR      R0,[R1, #+0]
    453            
    454            /* Go to error state if the UartRequest failed */
    455            if(Debug_Uart == NULL)
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable17
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0x2800             CMP      R0,#+0
   \   00000088   0xD105             BNE.N    ??DebugInitialize_4
    456            {
    457              Debug_pfnStateMachine = DebugSM_Error;
   \   0000008A   0x.... 0x....      ADR.W    R0,DebugSM_Error
   \   0000008E   0x.... 0x....      LDR.W    R1,??DataTable17_4
   \   00000092   0x6008             STR      R0,[R1, #+0]
   \   00000094   0xE010             B.N      ??DebugInitialize_5
    458          
    459            }
    460            /* Otherwise send the first message, set "good" flag and head to Idle */
    461            else
    462            {
    463              DebugPrintf(Debug_au8StartupMsg);   
   \                     ??DebugInitialize_4: (+1)
   \   00000096   0x.... 0x....      LDR.W    R0,??DataTable17_19
   \   0000009A   0x.... 0x....      BL       DebugPrintf
    464              G_u32ApplicationFlags |= _APPLICATION_FLAGS_DEBUG;
   \   0000009E   0x.... 0x....      LDR.W    R0,??DataTable17_13
   \   000000A2   0x6800             LDR      R0,[R0, #+0]
   \   000000A4   0xF050 0x0004      ORRS     R0,R0,#0x4
   \   000000A8   0x.... 0x....      LDR.W    R1,??DataTable17_13
   \   000000AC   0x6008             STR      R0,[R1, #+0]
    465              Debug_pfnStateMachine = DebugSM_Idle;
   \   000000AE   0x.... 0x....      ADR.W    R0,DebugSM_Idle
   \   000000B2   0x.... 0x....      LDR.W    R1,??DataTable17_4
   \   000000B6   0x6008             STR      R0,[R1, #+0]
    466            }
    467            
    468          } /* end  DebugInitialize() */
   \                     ??DebugInitialize_5: (+1)
   \   000000B8   0xB005             ADD      SP,SP,#+20
   \   000000BA   0xBD00             POP      {PC}             ;; return
    469          
    470          
    471          /*----------------------------------------------------------------------------------------------------------------------
    472          Function DebugRunActiveState()
    473          
    474          Description:
    475          Selects and runs one iteration of the current state in the state machine.
    476          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    477          may take 1ms / n to execute.
    478          
    479          Requires:
    480            - State machine function pointer points at current state
    481          
    482          Promises:
    483            - Calls the function to pointed by the state machine function pointer
    484          */

   \                                 In section .text, align 2, keep-with-next
    485          void DebugRunActiveState(void)
    486          {
   \                     DebugRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    487            Debug_pfnStateMachine();
   \   00000002   0x.... 0x....      LDR.W    R0,??DataTable17_4
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x4780             BLX      R0
    488          
    489          } /* end DebugRunActiveState */
   \   0000000A   0xBD01             POP      {R0,PC}          ;; return
    490          
    491          
    492          /*----------------------------------------------------------------------------------------------------------------------
    493          Function DebugRxCallback()
    494          
    495          Description:
    496          Call back function used when character received.
    497          
    498          Requires:
    499            - None
    500          
    501          Promises:
    502            - Safely advances Debug_pu8RxBufferNextChar.
    503          */

   \                                 In section .text, align 4, keep-with-next
    504          void DebugRxCallback(void)
    505          {
    506            /* Safely advance the NextChar pointer */
    507            Debug_pu8RxBufferNextChar++;
   \                     DebugRxCallback: (+1)
   \   00000000   0x.... 0x....      LDR.W    R0,??DataTable17_16
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x1C40             ADDS     R0,R0,#+1
   \   00000008   0x.... 0x....      LDR.W    R1,??DataTable17_16
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    508            if(Debug_pu8RxBufferNextChar == &Debug_au8RxBuffer[DEBUG_RX_BUFFER_SIZE])
   \   0000000E   0x.... 0x....      LDR.W    R0,??DataTable17_16
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable17_20
   \   00000018   0x4288             CMP      R0,R1
   \   0000001A   0xD104             BNE.N    ??DebugRxCallback_0
    509            {
    510              Debug_pu8RxBufferNextChar = &Debug_au8RxBuffer[0];
   \   0000001C   0x.... 0x....      LDR.W    R0,??DataTable17_14
   \   00000020   0x.... 0x....      LDR.W    R1,??DataTable17_16
   \   00000024   0x6008             STR      R0,[R1, #+0]
    511            }
    512            
    513          } /* end DebugRxCallback() */
   \                     ??DebugRxCallback_0: (+1)
   \   00000026   0x4770             BX       LR               ;; return
    514          
    515          
    516          /*--------------------------------------------------------------------------------------------------------------------*/
    517          /* Private Functions */
    518          /*--------------------------------------------------------------------------------------------------------------------*/
    519          
    520          /*----------------------------------------------------------------------------------------------------------------------
    521          Function DebugCommandPrepareList
    522          
    523          Description:
    524          Queues the entire list of debug commands available in the system so they will
    525          be sent out the debug UART for the user to view.
    526          
    527          Requires:
    528            - Message Sender application is running
    529          
    530          Promises:
    531            - Command numbers and names of all installed commands are queued to messagesender.
    532          */

   \                                 In section .text, align 2, keep-with-next
    533          static void DebugCommandPrepareList(void)
    534          {
   \                     DebugCommandPrepareList: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB092             SUB      SP,SP,#+72
    535            u8 au8ListHeading[] = "\n\n\rAvailable commands:\n\r";
   \   00000004   0xA80A             ADD      R0,SP,#+40
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable17_21
   \   0000000A   0x2219             MOVS     R2,#+25
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy
    536            u8 au8CommandLine[DEBUG_CMD_PREFIX_LENGTH + DEBUG_CMD_NAME_LENGTH + DEBUG_CMD_POSTFIX_LENGTH];
    537            
    538            /* Write static characters to command list line */
    539            au8CommandLine[2] = ':';
   \   00000010   0x203A             MOVS     R0,#+58
   \   00000012   0xF88D 0x0002      STRB     R0,[SP, #+2]
    540            au8CommandLine[3] = ' ';
   \   00000016   0x2020             MOVS     R0,#+32
   \   00000018   0xF88D 0x0003      STRB     R0,[SP, #+3]
    541            au8CommandLine[DEBUG_CMD_PREFIX_LENGTH + DEBUG_CMD_NAME_LENGTH] = '\n';
   \   0000001C   0x200A             MOVS     R0,#+10
   \   0000001E   0xF88D 0x0024      STRB     R0,[SP, #+36]
    542            au8CommandLine[DEBUG_CMD_PREFIX_LENGTH + DEBUG_CMD_NAME_LENGTH + 1] = '\r';
   \   00000022   0x200D             MOVS     R0,#+13
   \   00000024   0xF88D 0x0025      STRB     R0,[SP, #+37]
    543            au8CommandLine[DEBUG_CMD_PREFIX_LENGTH + DEBUG_CMD_NAME_LENGTH + 2] = '\0';
   \   00000028   0x2000             MOVS     R0,#+0
   \   0000002A   0xF88D 0x0026      STRB     R0,[SP, #+38]
    544          
    545            /* Prepare a nicely formatted list of commands */
    546            DebugPrintf(au8ListHeading);
   \   0000002E   0xA80A             ADD      R0,SP,#+40
   \   00000030   0x.... 0x....      BL       DebugPrintf
    547            
    548            /* Loop through the array of commands parsing out the command number
    549            and printing it along with the command name. */  
    550            for(u8 i = 0; i < DEBUG_COMMANDS; i++)
   \   00000034   0x2400             MOVS     R4,#+0
   \                     ??DebugCommandPrepareList_0: (+1)
   \   00000036   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000038   0x2C08             CMP      R4,#+8
   \   0000003A   0xDA2C             BGE.N    ??DebugCommandPrepareList_1
    551            {
    552              /* Get the command number in ASCII */
    553              if(i >= 10)
   \   0000003C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000003E   0x2C0A             CMP      R4,#+10
   \   00000040   0xDB07             BLT.N    ??DebugCommandPrepareList_2
    554              {
    555                au8CommandLine[0] = (i / 10) + 0x30;
   \   00000042   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000044   0x200A             MOVS     R0,#+10
   \   00000046   0xFB94 0xF0F0      SDIV     R0,R4,R0
   \   0000004A   0x3030             ADDS     R0,R0,#+48
   \   0000004C   0xF88D 0x0000      STRB     R0,[SP, #+0]
   \   00000050   0xE002             B.N      ??DebugCommandPrepareList_3
    556              }
    557              else
    558              {
    559                au8CommandLine[0] = 0x30;
   \                     ??DebugCommandPrepareList_2: (+1)
   \   00000052   0x2030             MOVS     R0,#+48
   \   00000054   0xF88D 0x0000      STRB     R0,[SP, #+0]
    560              }
    561              
    562              au8CommandLine[1] = (i % 10) + 0x30;
   \                     ??DebugCommandPrepareList_3: (+1)
   \   00000058   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005A   0x200A             MOVS     R0,#+10
   \   0000005C   0xFB94 0xF1F0      SDIV     R1,R4,R0
   \   00000060   0xFB00 0x4011      MLS      R0,R0,R1,R4
   \   00000064   0x3030             ADDS     R0,R0,#+48
   \   00000066   0xF88D 0x0001      STRB     R0,[SP, #+1]
    563              
    564              /* Read the command name */
    565              for(u8 j = 0; j < DEBUG_CMD_NAME_LENGTH; j++)
   \   0000006A   0x2000             MOVS     R0,#+0
   \                     ??DebugCommandPrepareList_4: (+1)
   \   0000006C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000006E   0x2820             CMP      R0,#+32
   \   00000070   0xDA0C             BGE.N    ??DebugCommandPrepareList_5
    566              {
    567                au8CommandLine[DEBUG_CMD_PREFIX_LENGTH + j] = Debug_au8Commands[i].pu8CommandName[j];
   \   00000072   0x.... 0x....      LDR.W    R1,??DataTable17_22
   \   00000076   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000078   0xF851 0x1034      LDR      R1,[R1, R4, LSL #+3]
   \   0000007C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000007E   0x5C41             LDRB     R1,[R0, R1]
   \   00000080   0xAA00             ADD      R2,SP,#+0
   \   00000082   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000084   0x1882             ADDS     R2,R0,R2
   \   00000086   0x7111             STRB     R1,[R2, #+4]
    568              }
   \   00000088   0x1C40             ADDS     R0,R0,#+1
   \   0000008A   0xE7EF             B.N      ??DebugCommandPrepareList_4
    569              
    570              /* Queue the command name to the UART */
    571              DebugPrintf(au8CommandLine);
   \                     ??DebugCommandPrepareList_5: (+1)
   \   0000008C   0xA800             ADD      R0,SP,#+0
   \   0000008E   0x.... 0x....      BL       DebugPrintf
    572            }
   \   00000092   0x1C64             ADDS     R4,R4,#+1
   \   00000094   0xE7CF             B.N      ??DebugCommandPrepareList_0
    573          
    574            DebugLineFeed();
   \                     ??DebugCommandPrepareList_1: (+1)
   \   00000096   0x.... 0x....      BL       DebugLineFeed
    575            
    576          } /* end DebugCommand0PrepareList() */
   \   0000009A   0xB012             ADD      SP,SP,#+72
   \   0000009C   0xBD10             POP      {R4,PC}          ;; return
    577          
    578          
    579          
    580          /*----------------------------------------------------------------------------------------------------------------------
    581          Function: DebugCommandDummy
    582          
    583          Description:
    584          A command place-holder.
    585          */

   \                                 In section .text, align 2, keep-with-next
    586          static void DebugCommandDummy(void)
    587          {
   \                     DebugCommandDummy: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    588            u8 au8DummyCommand[] = "\n\rDummy!\n\n\r";
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable17_23
   \   0000000A   0xC91C             LDM      R1!,{R2-R4}
   \   0000000C   0xC01C             STM      R0!,{R2-R4}
   \   0000000E   0x390C             SUBS     R1,R1,#+12
   \   00000010   0x380C             SUBS     R0,R0,#+12
    589            
    590            DebugPrintf(au8DummyCommand);
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x.... 0x....      BL       DebugPrintf
    591            
    592          } /* end DebugCommandDummy() */
   \   00000018   0xBD1F             POP      {R0-R4,PC}       ;; return
    593          
    594          
    595          /*----------------------------------------------------------------------------------------------------------------------
    596          Function: DebugCommandLedTestToggle
    597          
    598          Description:
    599          Toggles the active state of the LED test which allows typed characters corresponding to LED colors
    600          to toggle those LEDs on or off.  LEDs are started all ON.  They are left in their current state when
    601          the function exits.
    602          */

   \                                 In section .text, align 2, keep-with-next
    603          static void DebugCommandLedTestToggle(void)
    604          {
   \                     DebugCommandLedTestToggle: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0xB084             SUB      SP,SP,#+16
    605            u8 au8LedTestMessage[] = "\n\rLed Test ";
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable17_24
   \   0000000A   0xC91C             LDM      R1!,{R2-R4}
   \   0000000C   0xC01C             STM      R0!,{R2-R4}
   \   0000000E   0x390C             SUBS     R1,R1,#+12
   \   00000010   0x380C             SUBS     R0,R0,#+12
    606            
    607            /* Print message and toggle the flag */
    608            DebugPrintf(au8LedTestMessage);
   \   00000012   0xA800             ADD      R0,SP,#+0
   \   00000014   0x.... 0x....      BL       DebugPrintf
    609            if(G_u32DebugFlags & _DEBUG_LED_TEST_ENABLE)
   \   00000018   0x.... 0x....      LDR.W    R0,??DataTable17_7
   \   0000001C   0x7800             LDRB     R0,[R0, #+0]
   \   0000001E   0x07C0             LSLS     R0,R0,#+31
   \   00000020   0xD50C             BPL.N    ??DebugCommandLedTestToggle_0
    610            {
    611              G_u32DebugFlags &= ~_DEBUG_LED_TEST_ENABLE;
   \   00000022   0x.... 0x....      LDR.W    R0,??DataTable17_7
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x0840             LSRS     R0,R0,#+1
   \   0000002A   0x0040             LSLS     R0,R0,#+1
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable17_7
   \   00000030   0x6008             STR      R0,[R1, #+0]
    612              DebugPrintf(G_au8MessageOFF);
   \   00000032   0x.... 0x....      LDR.W    R0,??DataTable17_25
   \   00000036   0x.... 0x....      BL       DebugPrintf
   \   0000003A   0xE03B             B.N      ??DebugCommandLedTestToggle_1
    613            }
    614            else
    615            {
    616              G_u32DebugFlags |= _DEBUG_LED_TEST_ENABLE;
   \                     ??DebugCommandLedTestToggle_0: (+1)
   \   0000003C   0x.... 0x....      LDR.W    R0,??DataTable17_7
   \   00000040   0x6800             LDR      R0,[R0, #+0]
   \   00000042   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   00000046   0x.... 0x....      LDR.W    R1,??DataTable17_7
   \   0000004A   0x6008             STR      R0,[R1, #+0]
    617              DebugPrintf(G_au8MessageON);
   \   0000004C   0x.... 0x....      LDR.W    R0,??DataTable17_26
   \   00000050   0x.... 0x....      BL       DebugPrintf
    618              
    619          #ifdef MPG1
    620              LedOn(WHITE);
   \   00000054   0x2000             MOVS     R0,#+0
   \   00000056   0x.... 0x....      BL       LedOn
    621              LedOn(PURPLE);
   \   0000005A   0x2001             MOVS     R0,#+1
   \   0000005C   0x.... 0x....      BL       LedOn
    622              LedOn(BLUE);
   \   00000060   0x2002             MOVS     R0,#+2
   \   00000062   0x.... 0x....      BL       LedOn
    623              LedOn(CYAN);
   \   00000066   0x2003             MOVS     R0,#+3
   \   00000068   0x.... 0x....      BL       LedOn
    624              LedOn(GREEN);
   \   0000006C   0x2004             MOVS     R0,#+4
   \   0000006E   0x.... 0x....      BL       LedOn
    625              LedOn(YELLOW);
   \   00000072   0x2005             MOVS     R0,#+5
   \   00000074   0x.... 0x....      BL       LedOn
    626              LedOn(ORANGE);
   \   00000078   0x2006             MOVS     R0,#+6
   \   0000007A   0x.... 0x....      BL       LedOn
    627              LedOn(RED);
   \   0000007E   0x2007             MOVS     R0,#+7
   \   00000080   0x.... 0x....      BL       LedOn
    628          #endif /* MPG 1 */   
    629              
    630              #ifdef MPG1
    631              LedOn(WHITE);
   \   00000084   0x2000             MOVS     R0,#+0
   \   00000086   0x.... 0x....      BL       LedOn
    632              LedOn(PURPLE);
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0x.... 0x....      BL       LedOn
    633              LedOn(BLUE);
   \   00000090   0x2002             MOVS     R0,#+2
   \   00000092   0x.... 0x....      BL       LedOn
    634              LedOn(CYAN);
   \   00000096   0x2003             MOVS     R0,#+3
   \   00000098   0x.... 0x....      BL       LedOn
    635              LedOn(GREEN);
   \   0000009C   0x2004             MOVS     R0,#+4
   \   0000009E   0x.... 0x....      BL       LedOn
    636              LedOn(YELLOW);
   \   000000A2   0x2005             MOVS     R0,#+5
   \   000000A4   0x.... 0x....      BL       LedOn
    637              LedOn(ORANGE);
   \   000000A8   0x2006             MOVS     R0,#+6
   \   000000AA   0x.... 0x....      BL       LedOn
    638              LedOn(RED);
   \   000000AE   0x2007             MOVS     R0,#+7
   \   000000B0   0x.... 0x....      BL       LedOn
    639          #endif /* MPG 1 */
    640          
    641          #ifdef MPGL2
    642          #ifdef MPGL2_R01
    643              LedOn(BLUE);
    644              LedOn(GREEN);
    645              LedOn(YELLOW);
    646              LedOn(RED);
    647          #else
    648              LedOn(BLUE0);
    649              LedOn(BLUE1);
    650              LedOn(BLUE2);
    651              LedOn(BLUE3);
    652              LedOn(RED0);
    653              LedOn(RED1);
    654              LedOn(RED2);
    655              LedOn(RED3);
    656              LedOn(GREEN0);
    657              LedOn(GREEN1);
    658              LedOn(GREEN2);
    659              LedOn(GREEN3);
    660          #endif /* MPGL2_R01 */
    661          #endif /* MPGL2 */
    662            }
    663            
    664          } /* end DebugCommandLedTestToggle() */
   \                     ??DebugCommandLedTestToggle_1: (+1)
   \   000000B4   0xBD1F             POP      {R0-R4,PC}       ;; return
    665          
    666          
    667          /*----------------------------------------------------------------------------------------------------------------------
    668          Function: DebugLedTestCharacter
    669          
    670          Description:
    671          Checks the character and toggles associated LED if applicable.
    672          This implementation is specific to the target hardware.
    673          
    674          Requires:
    675            - u8Char_ is the character to check
    676          
    677          Promises:
    678            - If u8Char_ is a valid toggling character, the corresponding LED will be toggled.
    679          */

   \                                 In section .text, align 2, keep-with-next
    680          static void DebugLedTestCharacter(u8 u8Char_)
    681          {
   \                     DebugLedTestCharacter: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    682            /* Check the char to see if an LED should be toggled */  
    683          #ifdef MPGL1
    684            if(u8Char_ == 'W')
   \   00000004   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000006   0x2C57             CMP      R4,#+87
   \   00000008   0xD102             BNE.N    ??DebugLedTestCharacter_0
    685            {
    686              LedToggle(WHITE);
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x.... 0x....      BL       LedToggle
    687            }  
    688          
    689            if(u8Char_ == 'P')
   \                     ??DebugLedTestCharacter_0: (+1)
   \   00000010   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000012   0x2C50             CMP      R4,#+80
   \   00000014   0xD102             BNE.N    ??DebugLedTestCharacter_1
    690            {
    691              LedToggle(PURPLE);
   \   00000016   0x2001             MOVS     R0,#+1
   \   00000018   0x.... 0x....      BL       LedToggle
    692            } 
    693          
    694            if(u8Char_ == 'B')
   \                     ??DebugLedTestCharacter_1: (+1)
   \   0000001C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000001E   0x2C42             CMP      R4,#+66
   \   00000020   0xD102             BNE.N    ??DebugLedTestCharacter_2
    695            {
    696              LedToggle(BLUE);
   \   00000022   0x2002             MOVS     R0,#+2
   \   00000024   0x.... 0x....      BL       LedToggle
    697            } 
    698          
    699            if(u8Char_ == 'C')
   \                     ??DebugLedTestCharacter_2: (+1)
   \   00000028   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002A   0x2C43             CMP      R4,#+67
   \   0000002C   0xD102             BNE.N    ??DebugLedTestCharacter_3
    700            {
    701              LedToggle(CYAN);
   \   0000002E   0x2003             MOVS     R0,#+3
   \   00000030   0x.... 0x....      BL       LedToggle
    702            } 
    703          
    704            if(u8Char_ == 'G')
   \                     ??DebugLedTestCharacter_3: (+1)
   \   00000034   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000036   0x2C47             CMP      R4,#+71
   \   00000038   0xD102             BNE.N    ??DebugLedTestCharacter_4
    705            {
    706              LedToggle(GREEN);
   \   0000003A   0x2004             MOVS     R0,#+4
   \   0000003C   0x.... 0x....      BL       LedToggle
    707            } 
    708          
    709            if(u8Char_ == 'Y')
   \                     ??DebugLedTestCharacter_4: (+1)
   \   00000040   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000042   0x2C59             CMP      R4,#+89
   \   00000044   0xD102             BNE.N    ??DebugLedTestCharacter_5
    710            {
    711              LedToggle(YELLOW);
   \   00000046   0x2005             MOVS     R0,#+5
   \   00000048   0x.... 0x....      BL       LedToggle
    712            } 
    713          
    714            if(u8Char_ == 'O')
   \                     ??DebugLedTestCharacter_5: (+1)
   \   0000004C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000004E   0x2C4F             CMP      R4,#+79
   \   00000050   0xD102             BNE.N    ??DebugLedTestCharacter_6
    715            {
    716              LedToggle(ORANGE);
   \   00000052   0x2006             MOVS     R0,#+6
   \   00000054   0x.... 0x....      BL       LedToggle
    717            } 
    718          
    719            if(u8Char_ == 'R')
   \                     ??DebugLedTestCharacter_6: (+1)
   \   00000058   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000005A   0x2C52             CMP      R4,#+82
   \   0000005C   0xD102             BNE.N    ??DebugLedTestCharacter_7
    720            {
    721              LedToggle(RED);
   \   0000005E   0x2007             MOVS     R0,#+7
   \   00000060   0x.... 0x....      BL       LedToggle
    722            } 
    723          
    724          #endif /* MPGL1 */
    725            
    726          #ifdef MPGL2
    727            
    728          #ifdef MPGL2_R01
    729            if(u8Char_ == 'B')
    730            {
    731              LedToggle(BLUE);
    732            } 
    733          
    734            if(u8Char_ == 'G')
    735            {
    736              LedToggle(GREEN);
    737            } 
    738          
    739            if(u8Char_ == 'Y')
    740            {
    741              LedToggle(YELLOW);
    742            } 
    743          
    744            if(u8Char_ == 'R')
    745            {
    746              LedToggle(RED);
    747            } 
    748            
    749          #else
    750          
    751            if(u8Char_ == 'B')
    752            {
    753              LedToggle(BLUE0);
    754              LedToggle(BLUE1);
    755              LedToggle(BLUE2);
    756              LedToggle(BLUE3);
    757            }  
    758          
    759            if(u8Char_ == 'R')
    760            {
    761              LedToggle(RED0);
    762              LedToggle(RED1);
    763              LedToggle(RED2);
    764              LedToggle(RED3);
    765            }  
    766            
    767            if(u8Char_ == 'G')
    768            {
    769              LedToggle(GREEN0);
    770              LedToggle(GREEN1);
    771              LedToggle(GREEN2);
    772              LedToggle(GREEN3);
    773            }  
    774           
    775          #endif /* MPGL2_R01 */
    776          #endif /* MPGL2 */
    777            
    778          } /* end DebugCommandLedTestToggle() */
   \                     ??DebugLedTestCharacter_7: (+1)
   \   00000064   0xBD10             POP      {R4,PC}          ;; return
    779          
    780          
    781          /*----------------------------------------------------------------------------------------------------------------------
    782          Function: DebugCommandSysTimeToggle
    783          
    784          Description:
    785          Toggles the active state of the LED test which allows typed characters corresponding to LED colors
    786          to toggle those LEDs on or off.
    787          */

   \                                 In section .text, align 2, keep-with-next
    788          static void DebugCommandSysTimeToggle(void)
    789          {
   \                     DebugCommandSysTimeToggle: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB089             SUB      SP,SP,#+36
    790            u8 au8SysTimeTestMessage[] = "\n\rSystem time violation reporting ";
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x.... 0x....      LDR.W    R1,??DataTable17_27
   \   0000000A   0x2223             MOVS     R2,#+35
   \   0000000C   0x.... 0x....      BL       __aeabi_memcpy
    791            
    792            /* Print message and toggle the flag */
    793            DebugPrintf(au8SysTimeTestMessage);
   \   00000010   0xA800             ADD      R0,SP,#+0
   \   00000012   0x.... 0x....      BL       DebugPrintf
    794            if(G_u32DebugFlags & _DEBUG_TIME_WARNING_ENABLE)
   \   00000016   0x....             LDR.N    R0,??DataTable17_7
   \   00000018   0x7800             LDRB     R0,[R0, #+0]
   \   0000001A   0x0780             LSLS     R0,R0,#+30
   \   0000001C   0xD509             BPL.N    ??DebugCommandSysTimeToggle_0
    795            {
    796              G_u32DebugFlags &= ~_DEBUG_TIME_WARNING_ENABLE;
   \   0000001E   0x....             LDR.N    R0,??DataTable17_7
   \   00000020   0x6800             LDR      R0,[R0, #+0]
   \   00000022   0xF030 0x0002      BICS     R0,R0,#0x2
   \   00000026   0x....             LDR.N    R1,??DataTable17_7
   \   00000028   0x6008             STR      R0,[R1, #+0]
    797              DebugPrintf(G_au8MessageOFF);
   \   0000002A   0x....             LDR.N    R0,??DataTable17_25
   \   0000002C   0x.... 0x....      BL       DebugPrintf
   \   00000030   0xE008             B.N      ??DebugCommandSysTimeToggle_1
    798            }
    799            else
    800            {
    801              G_u32DebugFlags |= _DEBUG_TIME_WARNING_ENABLE;
   \                     ??DebugCommandSysTimeToggle_0: (+1)
   \   00000032   0x....             LDR.N    R0,??DataTable17_7
   \   00000034   0x6800             LDR      R0,[R0, #+0]
   \   00000036   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   0000003A   0x....             LDR.N    R1,??DataTable17_7
   \   0000003C   0x6008             STR      R0,[R1, #+0]
    802              DebugPrintf(G_au8MessageON);
   \   0000003E   0x....             LDR.N    R0,??DataTable17_26
   \   00000040   0x.... 0x....      BL       DebugPrintf
    803            }
    804            
    805          } /* end DebugCommandSysTimeToggle() */
   \                     ??DebugCommandSysTimeToggle_1: (+1)
   \   00000044   0xB009             ADD      SP,SP,#+36
   \   00000046   0xBD00             POP      {PC}             ;; return
    806          
    807          #ifdef MPGL2 /* MPGL2 only tests */
    808          /*----------------------------------------------------------------------------------------------------------------------
    809          Function: DebugCommandCaptouchValuesToggle
    810          
    811          Description:
    812          Toggles printing the current Captouch horizontal and vertical values.
    813          */
    814          static void DebugCommandCaptouchValuesToggle(void)
    815          {
    816            u8 au8CaptouchDisplayMessage[] = "\n\rDisplay Captouch values ";
    817            u8 au8CaptouchOnMessage[] = "No values displayed if Captouch is OFF\n\r";
    818            
    819            /* Print message and toggle the flag */
    820            DebugPrintf(au8CaptouchDisplayMessage);
    821            if(G_u32DebugFlags & _DEBUG_CAPTOUCH_VALUES_ENABLE)
    822            {
    823              G_u32DebugFlags &= ~_DEBUG_CAPTOUCH_VALUES_ENABLE;
    824              DebugPrintf(G_au8MessageOFF);
    825            }
    826            else
    827            {
    828              G_u32DebugFlags |= _DEBUG_CAPTOUCH_VALUES_ENABLE;
    829              DebugPrintf(G_au8MessageON);
    830              DebugPrintf(au8CaptouchOnMessage);
    831            }
    832            
    833          } /* end DebugCommandCaptouchValuesToggle() */
    834          #endif /* MPGL2 only tests */
    835          
    836          
    837          /***********************************************************************************************************************
    838          State Machine Function Declarations
    839          
    840          The debugger state machine monitors the receive buffer to grab characters as they come in
    841          from the interrupt-driven receiver and store them in the debug command buffer.  Nothing happens 
    842          until the user sends a CR indicating they think they've entered a valid command.  The command is
    843          checked and reacted to accordingly.
    844          ***********************************************************************************************************************/
    845          
    846          /*----------------------------------------------------------------------------------------------------------------------
    847          Waits for a byte to appear in the Rx buffer.  The BufferParser is always moved
    848          through all new characters placing them into the command buffer until it hits a CR or there are no new
    849          characters to read. If there is no CR in this iteration, nothing else occurs.
    850          
    851          Backspace: Echo the backspace and a space character to clear the character on screen; move Debug_pu8BufferCurrentChar back.
    852          CR: Advance states to process the command.
    853          Any other character: Echo it to the UART Tx and place a copy in Debug_au8CommandBuffer.
    854          */

   \                                 In section .text, align 4, keep-with-next
    855          void DebugSM_Idle(void)               
    856          {
   \                     DebugSM_Idle: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    857            bool bCommandFound = FALSE;
   \   00000002   0x2400             MOVS     R4,#+0
    858            u8 u8CurrentByte;
    859            static u8 au8BackspaceSequence[] = {ASCII_BACKSPACE, ' ', ASCII_BACKSPACE};
    860            static u8 au8CommandOverflow[] = "\r\n*** Command too long ***\r\n\n";
    861            
    862            /* Parse any new characters that have come in until no more chars or a command is found */
    863            while( (Debug_pu8RxBufferParser != Debug_pu8RxBufferNextChar) && (bCommandFound == FALSE) )
   \                     ??DebugSM_Idle_0: (+1)
   \   00000004   0x....             LDR.N    R0,??DataTable17_15
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x....             LDR.N    R1,??DataTable17_16
   \   0000000A   0x6809             LDR      R1,[R1, #+0]
   \   0000000C   0x4288             CMP      R0,R1
   \   0000000E   0xF000 0x809A      BEQ.W    ??DebugSM_Idle_1
   \   00000012   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000014   0x2C00             CMP      R4,#+0
   \   00000016   0xF040 0x8096      BNE.W    ??DebugSM_Idle_1
    864            {
    865              /* Grab a copy of the current byte and echo it back */
    866              u8CurrentByte = *Debug_pu8RxBufferParser;
   \   0000001A   0x....             LDR.N    R0,??DataTable17_15
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x7800             LDRB     R0,[R0, #+0]
   \   00000020   0x0005             MOVS     R5,R0
    867                  
    868              /* Process the character */
    869              switch (u8CurrentByte)
   \   00000022   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000024   0x0028             MOVS     R0,R5
   \   00000026   0x2808             CMP      R0,#+8
   \   00000028   0xD002             BEQ.N    ??DebugSM_Idle_2
   \   0000002A   0x280D             CMP      R0,#+13
   \   0000002C   0xD033             BEQ.N    ??DebugSM_Idle_3
   \   0000002E   0xE03C             B.N      ??DebugSM_Idle_4
    870              {
    871                /* Backspace: update command buffer pointer and send sequence to delete the char on the terminal */
    872                case(ASCII_BACKSPACE): 
    873                {
    874                  /* Process for scanf as long as we are not in Passthrough mode */
    875                  if( G_u32DebugFlags & _DEBUG_PASSTHROUGH )
   \                     ??DebugSM_Idle_2: (+1)
   \   00000030   0x....             LDR.N    R0,??DataTable17_7
   \   00000032   0x7800             LDRB     R0,[R0, #+0]
   \   00000034   0x0740             LSLS     R0,R0,#+29
   \   00000036   0xD50D             BPL.N    ??DebugSM_Idle_5
    876                  {        
    877                    if(G_u8DebugScanfCharCount < DEBUG_SCANF_BUFFER_SIZE)
   \   00000038   0x....             LDR.N    R0,??DataTable17_5
   \   0000003A   0x7800             LDRB     R0,[R0, #+0]
   \   0000003C   0x2880             CMP      R0,#+128
   \   0000003E   0xDA26             BGE.N    ??DebugSM_Idle_6
    878                    {
    879                      G_au8DebugScanfBuffer[G_u8DebugScanfCharCount] = u8CurrentByte;
   \   00000040   0x....             LDR.N    R0,??DataTable17_6
   \   00000042   0x....             LDR.N    R1,??DataTable17_5
   \   00000044   0x7809             LDRB     R1,[R1, #+0]
   \   00000046   0x540D             STRB     R5,[R1, R0]
    880                      G_u8DebugScanfCharCount++;
   \   00000048   0x....             LDR.N    R0,??DataTable17_5
   \   0000004A   0x7800             LDRB     R0,[R0, #+0]
   \   0000004C   0x1C40             ADDS     R0,R0,#+1
   \   0000004E   0x....             LDR.N    R1,??DataTable17_5
   \   00000050   0x7008             STRB     R0,[R1, #+0]
   \   00000052   0xE01C             B.N      ??DebugSM_Idle_6
    881                    }
    882                  }
    883                  else
    884                  {
    885                    if(G_u8DebugScanfCharCount != 0)
   \                     ??DebugSM_Idle_5: (+1)
   \   00000054   0x....             LDR.N    R0,??DataTable17_5
   \   00000056   0x7800             LDRB     R0,[R0, #+0]
   \   00000058   0x2800             CMP      R0,#+0
   \   0000005A   0xD009             BEQ.N    ??DebugSM_Idle_7
    886                    {
    887                      G_u8DebugScanfCharCount--;
   \   0000005C   0x....             LDR.N    R0,??DataTable17_5
   \   0000005E   0x7800             LDRB     R0,[R0, #+0]
   \   00000060   0x1E40             SUBS     R0,R0,#+1
   \   00000062   0x....             LDR.N    R1,??DataTable17_5
   \   00000064   0x7008             STRB     R0,[R1, #+0]
    888                      G_au8DebugScanfBuffer[G_u8DebugScanfCharCount] = '\0';
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x....             LDR.N    R1,??DataTable17_6
   \   0000006A   0x....             LDR.N    R2,??DataTable17_5
   \   0000006C   0x7812             LDRB     R2,[R2, #+0]
   \   0000006E   0x5450             STRB     R0,[R2, R1]
    889                    }
    890          
    891                    /* Process for command */
    892                    if(Debug_pu8CmdBufferNextChar != &Debug_au8CommandBuffer[0])
   \                     ??DebugSM_Idle_7: (+1)
   \   00000070   0x....             LDR.N    R0,??DataTable17_18
   \   00000072   0x6800             LDR      R0,[R0, #+0]
   \   00000074   0x....             LDR.N    R1,??DataTable17_17
   \   00000076   0x4288             CMP      R0,R1
   \   00000078   0xD009             BEQ.N    ??DebugSM_Idle_6
    893                    {
    894                      Debug_pu8CmdBufferNextChar--;
   \   0000007A   0x....             LDR.N    R0,??DataTable17_18
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0x1E40             SUBS     R0,R0,#+1
   \   00000080   0x....             LDR.N    R1,??DataTable17_18
   \   00000082   0x6008             STR      R0,[R1, #+0]
    895                      Debug_u16CommandSize--;
   \   00000084   0x....             LDR.N    R0,??DataTable17_28
   \   00000086   0x8800             LDRH     R0,[R0, #+0]
   \   00000088   0x1E40             SUBS     R0,R0,#+1
   \   0000008A   0x....             LDR.N    R1,??DataTable17_28
   \   0000008C   0x8008             STRH     R0,[R1, #+0]
    896                    }
    897                  }
    898                          
    899                  /* Send the Backspace sequence to clear the character on the terminal */
    900                  DebugPrintf(au8BackspaceSequence);
   \                     ??DebugSM_Idle_6: (+1)
   \   0000008E   0x....             LDR.N    R0,??DataTable17_29
   \   00000090   0x.... 0x....      BL       DebugPrintf
    901                  break;
   \   00000094   0xE040             B.N      ??DebugSM_Idle_8
    902                }
    903          
    904                /* Carriage return: change states to process new command and fall through to echo character */
    905                case(ASCII_CARRIAGE_RETURN): 
    906                {
    907                  if( !( G_u32DebugFlags & _DEBUG_PASSTHROUGH) )
   \                     ??DebugSM_Idle_3: (+1)
   \   00000096   0x....             LDR.N    R0,??DataTable17_7
   \   00000098   0x7800             LDRB     R0,[R0, #+0]
   \   0000009A   0x0740             LSLS     R0,R0,#+29
   \   0000009C   0xD405             BMI.N    ??DebugSM_Idle_4
    908                  {
    909                    bCommandFound = TRUE;
   \   0000009E   0x2001             MOVS     R0,#+1
   \   000000A0   0x0004             MOVS     R4,R0
    910                    Debug_pfnStateMachine = DebugSM_CheckCmd;
   \   000000A2   0x.... 0x....      ADR.W    R0,DebugSM_CheckCmd
   \   000000A6   0x....             LDR.N    R1,??DataTable17_4
   \   000000A8   0x6008             STR      R0,[R1, #+0]
    911                  }
    912                  
    913                  /* Fall through to default */        
    914                }
    915                  
    916                /* Add to command buffer and echo */
    917                default: 
    918                {
    919                  /* Process for scanf */
    920                  if(G_u8DebugScanfCharCount < DEBUG_SCANF_BUFFER_SIZE)
   \                     ??DebugSM_Idle_4: (+1)
   \   000000AA   0x....             LDR.N    R0,??DataTable17_5
   \   000000AC   0x7800             LDRB     R0,[R0, #+0]
   \   000000AE   0x2880             CMP      R0,#+128
   \   000000B0   0xDA08             BGE.N    ??DebugSM_Idle_9
    921                  {
    922                    G_au8DebugScanfBuffer[G_u8DebugScanfCharCount] = u8CurrentByte;
   \   000000B2   0x....             LDR.N    R0,??DataTable17_6
   \   000000B4   0x....             LDR.N    R1,??DataTable17_5
   \   000000B6   0x7809             LDRB     R1,[R1, #+0]
   \   000000B8   0x540D             STRB     R5,[R1, R0]
    923                    G_u8DebugScanfCharCount++;
   \   000000BA   0x....             LDR.N    R0,??DataTable17_5
   \   000000BC   0x7800             LDRB     R0,[R0, #+0]
   \   000000BE   0x1C40             ADDS     R0,R0,#+1
   \   000000C0   0x....             LDR.N    R1,??DataTable17_5
   \   000000C2   0x7008             STRB     R0,[R1, #+0]
    924                  }
    925                  
    926                  /* Echo the character back to the terminal */
    927                  UartWriteByte(Debug_Uart, u8CurrentByte);
   \                     ??DebugSM_Idle_9: (+1)
   \   000000C4   0x0029             MOVS     R1,R5
   \   000000C6   0xB2C9             UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
   \   000000C8   0x....             LDR.N    R0,??DataTable17
   \   000000CA   0x6800             LDR      R0,[R0, #+0]
   \   000000CC   0x.... 0x....      BL       UartWriteByte
    928                  
    929                  /* As long as Passthrough mode is not active, then update the command buffer */
    930                  if( !( G_u32DebugFlags & _DEBUG_PASSTHROUGH) )
   \   000000D0   0x....             LDR.N    R0,??DataTable17_7
   \   000000D2   0x7800             LDRB     R0,[R0, #+0]
   \   000000D4   0x0740             LSLS     R0,R0,#+29
   \   000000D6   0xD41F             BMI.N    ??DebugSM_Idle_10
    931                  {
    932                    *Debug_pu8CmdBufferNextChar = u8CurrentByte;
   \   000000D8   0x....             LDR.N    R0,??DataTable17_18
   \   000000DA   0x6800             LDR      R0,[R0, #+0]
   \   000000DC   0x7005             STRB     R5,[R0, #+0]
    933                    Debug_pu8CmdBufferNextChar++;
   \   000000DE   0x....             LDR.N    R0,??DataTable17_18
   \   000000E0   0x6800             LDR      R0,[R0, #+0]
   \   000000E2   0x1C40             ADDS     R0,R0,#+1
   \   000000E4   0x....             LDR.N    R1,??DataTable17_18
   \   000000E6   0x6008             STR      R0,[R1, #+0]
    934                    Debug_u16CommandSize++;
   \   000000E8   0x....             LDR.N    R0,??DataTable17_28
   \   000000EA   0x8800             LDRH     R0,[R0, #+0]
   \   000000EC   0x1C40             ADDS     R0,R0,#+1
   \   000000EE   0x....             LDR.N    R1,??DataTable17_28
   \   000000F0   0x8008             STRH     R0,[R1, #+0]
    935          
    936                    /* If the command buffer is now full but the last character was not ASCII_CARRIAGE_RETURN, throw out the whole
    937                    buffer and report an error message */
    938                    if( (Debug_pu8CmdBufferNextChar >= &Debug_au8CommandBuffer[DEBUG_CMD_BUFFER_SIZE]) &&
    939                        (u8CurrentByte != ASCII_CARRIAGE_RETURN) )
   \   000000F2   0x....             LDR.N    R0,??DataTable17_18
   \   000000F4   0x6800             LDR      R0,[R0, #+0]
   \   000000F6   0x....             LDR.N    R1,??DataTable17_30
   \   000000F8   0x4288             CMP      R0,R1
   \   000000FA   0xD30D             BCC.N    ??DebugSM_Idle_10
   \   000000FC   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   000000FE   0x2D0D             CMP      R5,#+13
   \   00000100   0xD00A             BEQ.N    ??DebugSM_Idle_10
    940                    {
    941                      Debug_pu8CmdBufferNextChar = &Debug_au8CommandBuffer[0];
   \   00000102   0x....             LDR.N    R0,??DataTable17_17
   \   00000104   0x....             LDR.N    R1,??DataTable17_18
   \   00000106   0x6008             STR      R0,[R1, #+0]
    942                      Debug_u16CommandSize = 0;
   \   00000108   0x2000             MOVS     R0,#+0
   \   0000010A   0x....             LDR.N    R1,??DataTable17_28
   \   0000010C   0x8008             STRH     R0,[R1, #+0]
    943          
    944                      Debug_u32CurrentMessageToken = DebugPrintf(au8CommandOverflow);
   \   0000010E   0x....             LDR.N    R0,??DataTable17_31
   \   00000110   0x.... 0x....      BL       DebugPrintf
   \   00000114   0x....             LDR.N    R1,??DataTable17_32
   \   00000116   0x6008             STR      R0,[R1, #+0]
    945                    }
    946                  }
    947                  break;
    948                }
    949          
    950              } /* end switch (u8RxChar) */
    951          
    952              /* If the LED test is active, toggle LEDs based on characters */
    953              if(G_u32DebugFlags & _DEBUG_LED_TEST_ENABLE)
   \                     ??DebugSM_Idle_10: (+1)
   \                     ??DebugSM_Idle_8: (+1)
   \   00000118   0x....             LDR.N    R0,??DataTable17_7
   \   0000011A   0x7800             LDRB     R0,[R0, #+0]
   \   0000011C   0x07C0             LSLS     R0,R0,#+31
   \   0000011E   0xD503             BPL.N    ??DebugSM_Idle_11
    954              {
    955                DebugLedTestCharacter(u8CurrentByte);
   \   00000120   0x0028             MOVS     R0,R5
   \   00000122   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000124   0x.... 0x....      BL       DebugLedTestCharacter
    956              }
    957              
    958              /* In all cases, advance the RxBufferParser pointer safely */
    959              Debug_pu8RxBufferParser++;
   \                     ??DebugSM_Idle_11: (+1)
   \   00000128   0x....             LDR.N    R0,??DataTable17_15
   \   0000012A   0x6800             LDR      R0,[R0, #+0]
   \   0000012C   0x1C40             ADDS     R0,R0,#+1
   \   0000012E   0x....             LDR.N    R1,??DataTable17_15
   \   00000130   0x6008             STR      R0,[R1, #+0]
    960              if(Debug_pu8RxBufferParser >= &Debug_au8RxBuffer[DEBUG_RX_BUFFER_SIZE])
   \   00000132   0x....             LDR.N    R0,??DataTable17_15
   \   00000134   0x6800             LDR      R0,[R0, #+0]
   \   00000136   0x....             LDR.N    R1,??DataTable17_20
   \   00000138   0x4288             CMP      R0,R1
   \   0000013A   0xF4FF 0xAF63      BCC.W    ??DebugSM_Idle_0
    961              {
    962                Debug_pu8RxBufferParser = &Debug_au8RxBuffer[0];
   \   0000013E   0x....             LDR.N    R0,??DataTable17_14
   \   00000140   0x....             LDR.N    R1,??DataTable17_15
   \   00000142   0x6008             STR      R0,[R1, #+0]
   \   00000144   0xE75E             B.N      ??DebugSM_Idle_0
    963              }
    964              
    965            } /* end while */
    966            
    967            /* Clear out any completed messages */
    968            if(Debug_u32CurrentMessageToken != 0)
   \                     ??DebugSM_Idle_1: (+1)
   \   00000146   0x....             LDR.N    R0,??DataTable17_32
   \   00000148   0x6800             LDR      R0,[R0, #+0]
   \   0000014A   0x2800             CMP      R0,#+0
   \   0000014C   0xD003             BEQ.N    ??DebugSM_Idle_12
    969            {
    970              QueryMessageStatus(Debug_u32CurrentMessageToken);
   \   0000014E   0x....             LDR.N    R0,??DataTable17_32
   \   00000150   0x6800             LDR      R0,[R0, #+0]
   \   00000152   0x.... 0x....      BL       QueryMessageStatus
    971            }
    972              
    973          } /* end DebugSM_Idle() */
   \                     ??DebugSM_Idle_12: (+1)
   \   00000156   0xBD31             POP      {R0,R4,R5,PC}    ;; return

   \                                 In section .data, align 4
   \                     ??au8BackspaceSequence:
   \   00000000   0x08 0x20          DC8 8, 32, 8, 0
   \              0x08 0x00    

   \                                 In section .data, align 4
   \                     ??au8CommandOverflow:
   \   00000000   0x0D 0x0A          DC8 "\015\012*** Command too long ***\015\012\012"
   \              0x2A 0x2A    
   \              0x2A 0x20    
   \              0x43 0x6F    
   \              0x6D 0x6D    
   \              0x61 0x6E    
   \              0x64 0x20    
   \              0x74 0x6F    
   \              0x6F 0x20    
   \              0x6C 0x6F    
   \              0x6E 0x67    
   \              0x20 0x2A    
   \              0x2A 0x2A    
   \              0x0D 0x0A    
   \              0x0A 0x00    
   \   0000001E   0x00 0x00          DC8 0, 0
    974          
    975          
    976          /*----------------------------------------------------------------------------------------------------------------------
    977          At the start of this state, the command buffer has a candidate command terminated in CR.
    978          There is a strict rule that commands are of the form
    979          en+cxx where xx is any number from 0 to DEBUG_COMMANDS, so parsing can be done based
    980          on that rule.  All other strings are invalid.  Debug interrupts remain off
    981          until the command is processed.
    982          */

   \                                 In section .text, align 4, keep-with-next
    983          void DebugSM_CheckCmd(void)        
    984          {
   \                     DebugSM_CheckCmd: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
    985            static u8 au8CommandHeader[] = "en+c";
    986            static u8 au8InvalidCommand[] = "\nInvalid command\n\n\r"; 
    987            bool bGoodCommand = TRUE;
   \   00000002   0x2401             MOVS     R4,#+1
    988            u8 u8Index;
    989            s8 s8Temp;
    990            
    991            /* Verify that the command starts with en+c */
    992            u8Index = 0;
   \   00000004   0x2000             MOVS     R0,#+0
   \   00000006   0x0005             MOVS     R5,R0
    993            do
    994            {
    995              if(Debug_au8CommandBuffer[u8Index] != au8CommandHeader[u8Index])
   \                     ??DebugSM_CheckCmd_0: (+1)
   \   00000008   0x....             LDR.N    R0,??DataTable17_17
   \   0000000A   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000000C   0x5C28             LDRB     R0,[R5, R0]
   \   0000000E   0x....             LDR.N    R1,??DataTable17_33
   \   00000010   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   0x5C69             LDRB     R1,[R5, R1]
   \   00000014   0x4288             CMP      R0,R1
   \   00000016   0xD001             BEQ.N    ??DebugSM_CheckCmd_1
    996              {
    997                bGoodCommand = FALSE;
   \   00000018   0x2000             MOVS     R0,#+0
   \   0000001A   0x0004             MOVS     R4,R0
    998              }
    999          
   1000              u8Index++;
   \                     ??DebugSM_CheckCmd_1: (+1)
   \   0000001C   0x1C6D             ADDS     R5,R5,#+1
   1001            } while ( bGoodCommand && (u8Index < 4) );
   \   0000001E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000020   0x2C00             CMP      R4,#+0
   \   00000022   0xD002             BEQ.N    ??DebugSM_CheckCmd_2
   \   00000024   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000026   0x2D04             CMP      R5,#+4
   \   00000028   0xDBEE             BLT.N    ??DebugSM_CheckCmd_0
   1002            
   1003            /* On good header, read the command number */
   1004            if(bGoodCommand)
   \                     ??DebugSM_CheckCmd_2: (+1)
   \   0000002A   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002C   0x2C00             CMP      R4,#+0
   \   0000002E   0xD02E             BEQ.N    ??DebugSM_CheckCmd_3
   1005            {
   1006              /* Make an assumption */
   1007              bGoodCommand = FALSE;
   \   00000030   0x2000             MOVS     R0,#+0
   \   00000032   0x0004             MOVS     R4,R0
   1008          
   1009              /* Verify the next char is a digit */
   1010              s8Temp = Debug_au8CommandBuffer[u8Index++] - 0x30;
   \   00000034   0x....             LDR.N    R0,??DataTable17_17
   \   00000036   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000038   0x5628             LDRSB    R0,[R5, R0]
   \   0000003A   0x3830             SUBS     R0,R0,#+48
   \   0000003C   0x0006             MOVS     R6,R0
   \   0000003E   0x1C6D             ADDS     R5,R5,#+1
   1011            
   1012              if( (s8Temp >= 0) && (s8Temp <= 9) )
   \   00000040   0xB276             SXTB     R6,R6            ;; SignExt  R6,R6,#+24,#+24
   \   00000042   0x2E00             CMP      R6,#+0
   \   00000044   0xD423             BMI.N    ??DebugSM_CheckCmd_3
   \   00000046   0xB276             SXTB     R6,R6            ;; SignExt  R6,R6,#+24,#+24
   \   00000048   0x2E0A             CMP      R6,#+10
   \   0000004A   0xDA20             BGE.N    ??DebugSM_CheckCmd_3
   1013              {
   1014                Debug_u8Command = s8Temp * 10;
   \   0000004C   0x200A             MOVS     R0,#+10
   \   0000004E   0xFB00 0xF006      MUL      R0,R0,R6
   \   00000052   0x....             LDR.N    R1,??DataTable17_34
   \   00000054   0x7008             STRB     R0,[R1, #+0]
   1015            
   1016                /* Verify the next char is a digit */
   1017                s8Temp = Debug_au8CommandBuffer[u8Index++] - 0x30;
   \   00000056   0x....             LDR.N    R0,??DataTable17_17
   \   00000058   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   0000005A   0x5628             LDRSB    R0,[R5, R0]
   \   0000005C   0x3830             SUBS     R0,R0,#+48
   \   0000005E   0x0006             MOVS     R6,R0
   \   00000060   0x1C6D             ADDS     R5,R5,#+1
   1018                if( (s8Temp >= 0) && (s8Temp <= 9) )
   \   00000062   0xB276             SXTB     R6,R6            ;; SignExt  R6,R6,#+24,#+24
   \   00000064   0x2E00             CMP      R6,#+0
   \   00000066   0xD412             BMI.N    ??DebugSM_CheckCmd_3
   \   00000068   0xB276             SXTB     R6,R6            ;; SignExt  R6,R6,#+24,#+24
   \   0000006A   0x2E0A             CMP      R6,#+10
   \   0000006C   0xDA0F             BGE.N    ??DebugSM_CheckCmd_3
   1019                {
   1020                  Debug_u8Command += s8Temp;
   \   0000006E   0x....             LDR.N    R0,??DataTable17_34
   \   00000070   0x7800             LDRB     R0,[R0, #+0]
   \   00000072   0x1830             ADDS     R0,R6,R0
   \   00000074   0x....             LDR.N    R1,??DataTable17_34
   \   00000076   0x7008             STRB     R0,[R1, #+0]
   1021                  
   1022                  /* Check that the command number is within the range of commands available and the last char is CR */
   1023                  if( (Debug_u8Command < DEBUG_COMMANDS) && (Debug_au8CommandBuffer[u8Index] == ASCII_CARRIAGE_RETURN) )
   \   00000078   0x....             LDR.N    R0,??DataTable17_34
   \   0000007A   0x7800             LDRB     R0,[R0, #+0]
   \   0000007C   0x2808             CMP      R0,#+8
   \   0000007E   0xDA06             BGE.N    ??DebugSM_CheckCmd_3
   \   00000080   0x....             LDR.N    R0,??DataTable17_17
   \   00000082   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000084   0x5C28             LDRB     R0,[R5, R0]
   \   00000086   0x280D             CMP      R0,#+13
   \   00000088   0xD101             BNE.N    ??DebugSM_CheckCmd_3
   1024                  {
   1025                    bGoodCommand = TRUE;
   \   0000008A   0x2001             MOVS     R0,#+1
   \   0000008C   0x0004             MOVS     R4,R0
   1026                  }
   1027                }
   1028              }
   1029            }
   1030                     
   1031            /* If still good command */
   1032            if( bGoodCommand )
   \                     ??DebugSM_CheckCmd_3: (+1)
   \   0000008E   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000090   0x2C00             CMP      R4,#+0
   \   00000092   0xD004             BEQ.N    ??DebugSM_CheckCmd_4
   1033            {
   1034              Debug_pfnStateMachine = DebugSM_ProcessCmd;
   \   00000094   0x.... 0x....      ADR.W    R0,DebugSM_ProcessCmd
   \   00000098   0x....             LDR.N    R1,??DataTable17_4
   \   0000009A   0x6008             STR      R0,[R1, #+0]
   \   0000009C   0xE005             B.N      ??DebugSM_CheckCmd_5
   1035            }
   1036            /* Otherwise print an error message and return to Idle */
   1037            else
   1038            { 
   1039              DebugPrintf(au8InvalidCommand);
   \                     ??DebugSM_CheckCmd_4: (+1)
   \   0000009E   0x....             LDR.N    R0,??DataTable17_35
   \   000000A0   0x.... 0x....      BL       DebugPrintf
   1040              Debug_pfnStateMachine = DebugSM_Idle;
   \   000000A4   0x....             LDR.N    R0,??DataTable17_36
   \   000000A6   0x....             LDR.N    R1,??DataTable17_4
   \   000000A8   0x6008             STR      R0,[R1, #+0]
   1041            }
   1042          
   1043            /* Reset the command buffer */
   1044            Debug_pu8CmdBufferNextChar = &Debug_au8CommandBuffer[0];
   \                     ??DebugSM_CheckCmd_5: (+1)
   \   000000AA   0x....             LDR.N    R0,??DataTable17_17
   \   000000AC   0x....             LDR.N    R1,??DataTable17_18
   \   000000AE   0x6008             STR      R0,[R1, #+0]
   1045          
   1046          } /* end DebugSM_CheckCmd() */
   \   000000B0   0xBD70             POP      {R4-R6,PC}       ;; return

   \                                 In section .data, align 4
   \                     ??au8CommandHeader:
   \   00000000   0x65 0x6E          DC8 "en+c"
   \              0x2B 0x63    
   \              0x00         
   \   00000005   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .data, align 4
   \                     ??au8InvalidCommand:
   \   00000000   0x0A 0x49          DC8 "\012Invalid command\012\012\015"
   \              0x6E 0x76    
   \              0x61 0x6C    
   \              0x69 0x64    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x0A 0x0A    
   \              0x0D 0x00    
   1047          
   1048          
   1049          /*----------------------------------------------------------------------------------------------------------------------
   1050          Carry out the debug instruction. 
   1051          */

   \                                 In section .text, align 4, keep-with-next
   1052          void DebugSM_ProcessCmd(void)         
   1053          {
   \                     DebugSM_ProcessCmd: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1054            /* Setup for return to Idle state */
   1055            Debug_pfnStateMachine = DebugSM_Idle;
   \   00000002   0x....             LDR.N    R0,??DataTable17_36
   \   00000004   0x....             LDR.N    R1,??DataTable17_4
   \   00000006   0x6008             STR      R0,[R1, #+0]
   1056          
   1057            /* Call the command function in the function array (may change next state ) */
   1058            Debug_au8Commands[Debug_u8Command].DebugFunction();
   \   00000008   0x....             LDR.N    R0,??DataTable17_22
   \   0000000A   0x....             LDR.N    R1,??DataTable17_34
   \   0000000C   0x7809             LDRB     R1,[R1, #+0]
   \   0000000E   0xEB10 0x00C1      ADDS     R0,R0,R1, LSL #+3
   \   00000012   0x6840             LDR      R0,[R0, #+4]
   \   00000014   0x4780             BLX      R0
   1059            
   1060          } /* end DebugSM_ProcessCmd() */
   \   00000016   0xBD01             POP      {R0,PC}          ;; return
   1061          
   1062          
   1063          /*----------------------------------------------------------------------------------------------------------------------
   1064          Error state 
   1065          Attempt to print an error message (even though if the Debug UART has failed, then it obviously cannot print
   1066          a message to tell you that!)
   1067          */

   \                                 In section .text, align 4, keep-with-next
   1068          void DebugSM_Error(void)         
   1069          {
   \                     DebugSM_Error: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1070            static u8 au8DebugErrorMsg[] = "\n\nDebug task error: ";
   1071            
   1072            /* Flag an error and report it (if possible) */
   1073            G_u32DebugFlags |= _DEBUG_FLAG_ERROR;
   \   00000002   0x....             LDR.N    R0,??DataTable17_7
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF050 0x4000      ORRS     R0,R0,#0x80000000
   \   0000000A   0x....             LDR.N    R1,??DataTable17_7
   \   0000000C   0x6008             STR      R0,[R1, #+0]
   1074            DebugPrintf(au8DebugErrorMsg);
   \   0000000E   0x....             LDR.N    R0,??DataTable17_37
   \   00000010   0x.... 0x....      BL       DebugPrintf
   1075            DebugPrintNumber( (u32)(Debug_u8ErrorCode) );
   \   00000014   0x....             LDR.N    R0,??DataTable17_3
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x.... 0x....      BL       DebugPrintNumber
   1076            DebugLineFeed();
   \   0000001C   0x.... 0x....      BL       DebugLineFeed
   1077            
   1078            /* Return to Idle state */
   1079            Debug_u16CommandSize = 0;
   \   00000020   0x2000             MOVS     R0,#+0
   \   00000022   0x....             LDR.N    R1,??DataTable17_28
   \   00000024   0x8008             STRH     R0,[R1, #+0]
   1080            Debug_pu8CmdBufferNextChar = &Debug_au8CommandBuffer[0];
   \   00000026   0x....             LDR.N    R0,??DataTable17_17
   \   00000028   0x....             LDR.N    R1,??DataTable17_18
   \   0000002A   0x6008             STR      R0,[R1, #+0]
   1081            Debug_pfnStateMachine = DebugSM_Idle;
   \   0000002C   0x....             LDR.N    R0,??DataTable17_36
   \   0000002E   0x....             LDR.N    R1,??DataTable17_4
   \   00000030   0x6008             STR      R0,[R1, #+0]
   1082          
   1083          } /* end DebugSM_Error() */
   \   00000032   0xBD01             POP      {R0,PC}          ;; return

   \                                 In section .data, align 4
   \                     ??au8DebugErrorMsg:
   \   00000000   0x0A 0x0A          DC8 "\012\012Debug task error: "
   \              0x44 0x65    
   \              0x62 0x75    
   \              0x67 0x20    
   \              0x74 0x61    
   \              0x73 0x6B    
   \              0x20 0x65    
   \              0x72 0x72    
   \              0x6F 0x72    
   \              0x3A 0x20    
   \              0x00         
   \   00000015   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17:
   \   00000000   0x........         DC32     Debug_Uart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_1:
   \   00000000   0x........         DC32     ?_8

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_2:
   \   00000000   0x3B9ACA00         DC32     0x3b9aca00

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_3:
   \   00000000   0x........         DC32     Debug_u8ErrorCode

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_4:
   \   00000000   0x........         DC32     Debug_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_5:
   \   00000000   0x........         DC32     G_u8DebugScanfCharCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_6:
   \   00000000   0x........         DC32     G_au8DebugScanfBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_7:
   \   00000000   0x........         DC32     G_u32DebugFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_8:
   \   00000000   0x........         DC32     ?_9

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_9:
   \   00000000   0x........         DC32     ?_10

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_10:
   \   00000000   0x........         DC32     ?_11

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_11:
   \   00000000   0x........         DC32     ?_12

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_12:
   \   00000000   0x........         DC32     ?_13

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_13:
   \   00000000   0x........         DC32     G_u32ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_14:
   \   00000000   0x........         DC32     Debug_au8RxBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_15:
   \   00000000   0x........         DC32     Debug_pu8RxBufferParser

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_16:
   \   00000000   0x........         DC32     Debug_pu8RxBufferNextChar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_17:
   \   00000000   0x........         DC32     Debug_au8CommandBuffer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_18:
   \   00000000   0x........         DC32     Debug_pu8CmdBufferNextChar

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_19:
   \   00000000   0x........         DC32     Debug_au8StartupMsg

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_20:
   \   00000000   0x........         DC32     Debug_au8RxBuffer+0x80

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_21:
   \   00000000   0x........         DC32     ?_14

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_22:
   \   00000000   0x........         DC32     Debug_au8Commands

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_23:
   \   00000000   0x........         DC32     ?_15

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_24:
   \   00000000   0x........         DC32     ?_16

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_25:
   \   00000000   0x........         DC32     G_au8MessageOFF

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_26:
   \   00000000   0x........         DC32     G_au8MessageON

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_27:
   \   00000000   0x........         DC32     ?_17

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_28:
   \   00000000   0x........         DC32     Debug_u16CommandSize

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_29:
   \   00000000   0x........         DC32     ??au8BackspaceSequence

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_30:
   \   00000000   0x........         DC32     Debug_au8CommandBuffer+0x40

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_31:
   \   00000000   0x........         DC32     ??au8CommandOverflow

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_32:
   \   00000000   0x........         DC32     Debug_u32CurrentMessageToken

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_33:
   \   00000000   0x........         DC32     ??au8CommandHeader

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_34:
   \   00000000   0x........         DC32     Debug_u8Command

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_35:
   \   00000000   0x........         DC32     ??au8InvalidCommand

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_36:
   \   00000000   0x........         DC32     DebugSM_Idle

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable17_37:
   \   00000000   0x........         DC32     ??au8DebugErrorMsg

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x53 0x68          DC8 "Show debug command list         "
   \              0x6F 0x77    
   \              0x20 0x64    
   \              0x65 0x62    
   \              0x75 0x67    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x20 0x6C    
   \              0x69 0x73    
   \              0x74 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x54 0x6F          DC8 "Toggle LED test                 "
   \              0x67 0x67    
   \              0x6C 0x65    
   \              0x20 0x4C    
   \              0x45 0x44    
   \              0x20 0x74    
   \              0x65 0x73    
   \              0x74 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_2:
   \   00000000   0x54 0x6F          DC8 "Toggle system timing warning    "
   \              0x67 0x67    
   \              0x6C 0x65    
   \              0x20 0x73    
   \              0x79 0x73    
   \              0x74 0x65    
   \              0x6D 0x20    
   \              0x74 0x69    
   \              0x6D 0x69    
   \              0x6E 0x67    
   \              0x20 0x77    
   \              0x61 0x72    
   \              0x6E 0x69    
   \              0x6E 0x67    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_3:
   \   00000000   0x44 0x75          DC8 "Dummy3                          "
   \              0x6D 0x6D    
   \              0x79 0x33    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_4:
   \   00000000   0x44 0x75          DC8 "Dummy4                          "
   \              0x6D 0x6D    
   \              0x79 0x34    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_5:
   \   00000000   0x44 0x75          DC8 "Dummy5                          "
   \              0x6D 0x6D    
   \              0x79 0x35    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_6:
   \   00000000   0x44 0x75          DC8 "Dummy6                          "
   \              0x6D 0x6D    
   \              0x79 0x36    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_7:
   \   00000000   0x44 0x75          DC8 "Dummy7                          "
   \              0x6D 0x6D    
   \              0x79 0x37    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x20 0x20    
   \              0x00         
   \   00000021   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 2
   \                     ?_8:
   \   00000000   0x0A 0x0D          DC8 10, 13

   \                                 In section .rodata, align 4
   \                     ?_9:
   \   00000000   0x0A 0x0A          DC8 "\012\012\015***Debug Passthrough enabled***\012\012\015"
   \              0x0D 0x2A    
   \              0x2A 0x2A    
   \              0x44 0x65    
   \              0x62 0x75    
   \              0x67 0x20    
   \              0x50 0x61    
   \              0x73 0x73    
   \              0x74 0x68    
   \              0x72 0x6F    
   \              0x75 0x67    
   \              0x68 0x20    
   \              0x65 0x6E    
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x64 0x2A    
   \              0x2A 0x2A    
   \              0x0A 0x0A    
   \              0x0D 0x00    
   \   00000026   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_10:
   \   00000000   0x0A 0x0A          DC8 "\012\012\015***Debug Passthrough disabled***\012\012\015"
   \              0x0D 0x2A    
   \              0x2A 0x2A    
   \              0x44 0x65    
   \              0x62 0x75    
   \              0x67 0x20    
   \              0x50 0x61    
   \              0x73 0x73    
   \              0x74 0x68    
   \              0x72 0x6F    
   \              0x75 0x67    
   \              0x68 0x20    
   \              0x64 0x69    
   \              0x73 0x61    
   \              0x62 0x6C    
   \              0x65 0x64    
   \              0x2A 0x2A    
   \              0x2A 0x0A    
   \              0x0A 0x0D    
   \              0x00         
   \   00000027   0x00               DC8 0

   \                                 In section .rodata, align 4
   \                     ?_11:
   \   00000000   0x4E 0x6F          DC8 "No failed tasks."
   \              0x20 0x66    
   \              0x61 0x69    
   \              0x6C 0x65    
   \              0x64 0x20    
   \              0x74 0x61    
   \              0x73 0x6B    
   \              0x73 0x2E    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_12:
   \   00000000   0x0A 0x0D          DC8 0AH, 0DH, 49H, 6EH, 69H, 74H, 69H, 61H
   \              0x49 0x6E    
   \              0x69 0x74    
   \              0x69 0x61    
   \   00000008   0x6C 0x69          DC8 6CH, 69H, 7AH, 61H, 74H, 69H, 6FH, 6EH
   \              0x7A 0x61    
   \              0x74 0x69    
   \              0x6F 0x6E    
   \   00000010   0x20 0x63          DC8 20H, 63H, 6FH, 6DH, 70H, 6CH, 65H, 74H
   \              0x6F 0x6D    
   \              0x70 0x6C    
   \              0x65 0x74    
   \   00000018   0x65 0x2E          DC8 65H, 2EH, 20H, 54H, 79H, 70H, 65H, 20H
   \              0x20 0x54    
   \              0x79 0x70    
   \              0x65 0x20    
   \   00000020   0x65 0x6E          DC8 65H, 6EH, 2BH, 63H, 30H, 30H, 20H, 66H
   \              0x2B 0x63    
   \              0x30 0x30    
   \              0x20 0x66    
   \   00000028   0x6F 0x72          DC8 6FH, 72H, 20H, 64H, 65H, 62H, 75H, 67H
   \              0x20 0x64    
   \              0x65 0x62    
   \              0x75 0x67    
   \   00000030   0x20 0x6D          DC8 20H, 6DH, 65H, 6EH, 75H, 2EH, 20H, 20H
   \              0x65 0x6E    
   \              0x75 0x2E    
   \              0x20 0x20    
   \   00000038   0x46 0x61          DC8 46H, 61H, 69H, 6CH, 65H, 64H, 20H, 74H
   \              0x69 0x6C    
   \              0x65 0x64    
   \              0x20 0x74    
   \   00000040   0x61 0x73          DC8 61H, 73H, 6BH, 73H, 3AH, 0AH, 0DH, 0
   \              0x6B 0x73    
   \              0x3A 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_13:
   \   00000000   0x4C 0x45          DC8 "LED"
   \              0x44 0x00    
   \   00000004   0x00 0x00          DC8 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   0000000A   0x42 0x55          DC8 "BUTTON"
   \              0x54 0x54    
   \              0x4F 0x4E    
   \              0x00         
   \   00000011   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   \   00000014   0x44 0x45          DC8 "DEBUG"
   \              0x42 0x55    
   \              0x47 0x00    
   \   0000001A   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000001E   0x4C 0x43          DC8 "LCD"
   \              0x44 0x00    
   \   00000022   0x00 0x00          DC8 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000028   0x41 0x4E          DC8 "ANT"
   \              0x54 0x00    
   \   0000002C   0x00 0x00          DC8 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \   00000032   0x54 0x49          DC8 "TIMER"
   \              0x4D 0x45    
   \              0x52 0x00    
   \   00000038   0x00 0x00          DC8 0, 0, 0, 0
   \              0x00 0x00    
   \   0000003C   0x53 0x44          DC8 "SD"
   \              0x00         
   \   0000003F   0x00 0x00          DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00 0x00    
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_14:
   \   00000000   0x0A 0x0A          DC8 "\012\012\015Available commands:\012\015"
   \              0x0D 0x41    
   \              0x76 0x61    
   \              0x69 0x6C    
   \              0x61 0x62    
   \              0x6C 0x65    
   \              0x20 0x63    
   \              0x6F 0x6D    
   \              0x6D 0x61    
   \              0x6E 0x64    
   \              0x73 0x3A    
   \              0x0A 0x0D    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         

   \                                 In section .rodata, align 4
   \                     ?_15:
   \   00000000   0x0A 0x0D          DC8 "\012\015Dummy!\012\012\015"
   \              0x44 0x75    
   \              0x6D 0x6D    
   \              0x79 0x21    
   \              0x0A 0x0A    
   \              0x0D 0x00    

   \                                 In section .rodata, align 4
   \                     ?_16:
   \   00000000   0x0A 0x0D          DC8 "\012\015Led Test "
   \              0x4C 0x65    
   \              0x64 0x20    
   \              0x54 0x65    
   \              0x73 0x74    
   \              0x20 0x00    

   \                                 In section .rodata, align 4
   \                     ?_17:
   \   00000000   0x0A 0x0D          DC8 "\012\015System time violation reporting "
   \              0x53 0x79    
   \              0x73 0x74    
   \              0x65 0x6D    
   \              0x20 0x74    
   \              0x69 0x6D    
   \              0x65 0x20    
   \              0x76 0x69    
   \              0x6F 0x6C    
   \              0x61 0x74    
   \              0x69 0x6F    
   \              0x6E 0x20    
   \              0x72 0x65    
   \              0x70 0x6F    
   \              0x72 0x74    
   \              0x69 0x6E    
   \              0x67 0x20    
   \              0x00         
   \   00000023   0x00               DC8 0
   1084                       
   1085          
   1086                    
   1087                       
   1088          /*--------------------------------------------------------------------------------------------------------------------*/
   1089          /* End of File                                                                                                        */
   1090          /*--------------------------------------------------------------------------------------------------------------------*/
   1091          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   DebugClearPassthrough
         8   -> DebugPrintf
      24   DebugCommandDummy
        24   -> DebugPrintf
      24   DebugCommandLedTestToggle
        24   -> DebugPrintf
        24   -> LedOn
      80   DebugCommandPrepareList
        80   -> DebugLineFeed
        80   -> DebugPrintf
        80   -> __aeabi_memcpy
      40   DebugCommandSysTimeToggle
        40   -> DebugPrintf
        40   -> __aeabi_memcpy
      24   DebugInitialize
        24   -> DebugPrintf
        24   -> UartRequest
       8   DebugLedTestCharacter
         8   -> LedToggle
       8   DebugLineFeed
         8   -> UartWriteData
      40   DebugPrintNumber
        40   -> UartWriteData
        40   -> free
        40   -> malloc
      16   DebugPrintf
        16   -> UartWriteData
       8   DebugRunActiveState
         8   -- Indirect call
       0   DebugRxCallback
      16   DebugSM_CheckCmd
        16   -> DebugPrintf
       8   DebugSM_Error
         8   -> DebugLineFeed
         8   -> DebugPrintNumber
         8   -> DebugPrintf
      16   DebugSM_Idle
        16   -> DebugLedTestCharacter
        16   -> DebugPrintf
        16   -> QueryMessageStatus
        16   -> UartWriteByte
       8   DebugSM_ProcessCmd
         8   -- Indirect call
       4   DebugScanf
       8   DebugSetPassthrough
         8   -> DebugPrintf
     192   SystemStatusReport
       192   -> DebugLineFeed
       192   -> DebugPrintf
       192   -> __aeabi_memcpy
       192   -> __aeabi_memcpy4


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable17
       4  ??DataTable17_1
       4  ??DataTable17_10
       4  ??DataTable17_11
       4  ??DataTable17_12
       4  ??DataTable17_13
       4  ??DataTable17_14
       4  ??DataTable17_15
       4  ??DataTable17_16
       4  ??DataTable17_17
       4  ??DataTable17_18
       4  ??DataTable17_19
       4  ??DataTable17_2
       4  ??DataTable17_20
       4  ??DataTable17_21
       4  ??DataTable17_22
       4  ??DataTable17_23
       4  ??DataTable17_24
       4  ??DataTable17_25
       4  ??DataTable17_26
       4  ??DataTable17_27
       4  ??DataTable17_28
       4  ??DataTable17_29
       4  ??DataTable17_3
       4  ??DataTable17_30
       4  ??DataTable17_31
       4  ??DataTable17_32
       4  ??DataTable17_33
       4  ??DataTable17_34
       4  ??DataTable17_35
       4  ??DataTable17_36
       4  ??DataTable17_37
       4  ??DataTable17_4
       4  ??DataTable17_5
       4  ??DataTable17_6
       4  ??DataTable17_7
       4  ??DataTable17_8
       4  ??DataTable17_9
      36  ?_0
      36  ?_1
      40  ?_10
      20  ?_11
      72  ?_12
      80  ?_13
      28  ?_14
      12  ?_15
      12  ?_16
      36  ?_17
      36  ?_2
      36  ?_3
      36  ?_4
      36  ?_5
      36  ?_6
      36  ?_7
       2  ?_8
      40  ?_9
      28  DebugClearPassthrough
      26  DebugCommandDummy
     182  DebugCommandLedTestToggle
     158  DebugCommandPrepareList
      72  DebugCommandSysTimeToggle
     188  DebugInitialize
     102  DebugLedTestCharacter
      28  DebugLineFeed
     176  DebugPrintNumber
      36  DebugPrintf
      12  DebugRunActiveState
      40  DebugRxCallback
     178  DebugSM_CheckCmd
      52  DebugSM_Error
     344  DebugSM_Idle
      24  DebugSM_ProcessCmd
      64  DebugScanf
      28  DebugSetPassthrough
       4  Debug_Uart
      64  Debug_au8CommandBuffer
      64  Debug_au8Commands
     128  Debug_au8RxBuffer
      68  Debug_au8StartupMsg
       4  Debug_pfnStateMachine
       4  Debug_pu8CmdBufferNextChar
       4  Debug_pu8RxBufferNextChar
       4  Debug_pu8RxBufferParser
       2  Debug_u16CommandSize
       4  Debug_u32CurrentMessageToken
       1  Debug_u8Command
       1  Debug_u8ErrorCode
     128  G_au8DebugScanfBuffer
       4  G_u32DebugFlags
       1  G_u8DebugScanfCharCount
     116  SystemStatusReport
       4  au8BackspaceSequence
       8  au8CommandHeader
      32  au8CommandOverflow
      24  au8DebugErrorMsg
      20  au8InvalidCommand

 
   353 bytes in section .bss
   220 bytes in section .data
   630 bytes in section .rodata
 2 006 bytes in section .text
 
 2 006 bytes of CODE  memory
   630 bytes of CONST memory
   573 bytes of DATA  memory

Errors: none
Warnings: none
