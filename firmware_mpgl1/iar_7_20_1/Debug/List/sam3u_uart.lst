###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.2.7424/W32 for ARM        14/May/2017  11:28:20
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpg_common\drivers\sam3u_uart.c
#    Command line =  
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpg_common\drivers\sam3u_uart.c
#        -D MPGL1 -D MPG1 -D EIE1 --preprocess=cl
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\Debug\List\
#        -lC
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\Debug\List\
#        -o
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\ -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\..\bsp\
#        -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\..\drivers\
#        -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\..\application\
#        -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\
#        -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\application\
#        -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\cmsis\
#        -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\Debug\List\sam3u_uart.lst
#    Object file  =  
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\Debug\Obj\sam3u_uart.o
#
###############################################################################

D:\Documents\GitHub\5-5eie\5_course\firmware_mpg_common\drivers\sam3u_uart.c
      1          /**********************************************************************************************************************
      2          File: sam3u_uart.c                                                                
      3          
      4          Description:
      5          Provides a driver to use UART peripherals to send and receive data using interrupts. 
      6          This driver covers both the dedicated UART peripheral and the three USART peripherals (assuming they are
      7          running in asynchronous (UART) mode).
      8          
      9          UART0 (38,400 8-N-1) gets special treatment to allow it to run very simply since it is only a debug interface.  The transmit buffer is
     10          owned by this source file and is accessed through the API.
     11          
     12          
     13          ------------------------------------------------------------------------------------------------------------------------
     14          API:
     15          Simple Public Debug UART functions:
     16          void Uart_putc(u8 u8Char_)
     17          bool UartCheckForNewChar(void)
     18          u8 Uart_getc(void)
     19          
     20          Generic Public UART functions
     21          UartPeripheralType* UartRequest(UartConfigurationType* psUartConfig_);
     22          Request a UART peripheral for your task.  No other tasks in the system will be able to access 
     23          the specific UART peripheral you request.
     24          e.g. MyTaskUart = UartRequest(&MyTaskUartConfig);
     25          
     26          void UartRelease(UartPeripheralType* psUartPeripheral_);
     27          If your task is done using the UART it requested, call this function to "give it back" to the system.
     28          e.g. UartRelease(&MyTaskUart);
     29          
     30          u32 UartWriteByte(UartPeripheralType* psUartPeripheral_, u8 u8Byte_);
     31          Write a single byte to the UART.  A token corresponding to the message is returned if you want to monitor
     32          if the byte sends correctly.
     33          e.g u32CurrentMessageToken = UartWriteByte(&MyTaskUart, 'A');
     34          
     35          u32 UartWriteData(UartPeripheralType* psUartPeripheral_, u32 u32Size_, u8* u8Data_);
     36          Write an array of bytes to the UART.  Returns the message token for monitoring the status of the message.
     37          e.g. 
     38          u8 au8Sting[] = "Send this string!\n\r";
     39          u32CurrentMessageToken = UartWriteData(&MyTaskUart, strlen(au8Sting), au8Sting);
     40          
     41          All receive functionality is automatic. Incoming bytes are deposited to the 
     42          buffer specified in psUartConfig_
     43          
     44          Both Tx and Rx use the peripheral DMA controller, though received bytes
     45          are always received one at a time to allow use of a circular buffer by the
     46          client task.
     47          
     48          INITIALIZATION (should take place in application's initialization function):
     49          1. Create a variable of UartConfigurationType in your application and initialize it to the desired UART peripheral,
     50          the address of the receive buffer for the application and the size in bytes of the receive buffer.
     51          
     52          2. Call UartRequest() with pointer to the configuration variable created in step 1.  The returned pointer is the
     53          UartPeripheralType object created that will be used by your application and should be assigned to a variable
     54          accessible to your application.
     55          
     56          3. If the application no longer needs the UART resource, call UartRelease().  
     57          
     58          DATA TRANSFER:
     59          1. Received bytes on the allocated peripheral will be dropped into the application's designated receive
     60          buffer.  The buffer is written circularly, with no provision to monitor bytes that are overwritten.  The 
     61          application is responsible for processing all received data.  The application must provide its own parsing
     62          pointer to read the receive buffer and properly wrap around.  This pointer will not be impacted by the interrupt
     63          service routine that may add additional characters at any time.
     64          
     65          2. Transmitted data is queued using one of two functions, UartWriteByte() and UartWriteData().  Once the data
     66          is queued, it is sent as soon as possible.  Each UART resource has a transmit queue, but only one UART resource
     67          will send data at any given time from this state machine.  However, all UART resources may receive data simultaneously
     68          through their respective interrupt handlers based on interrupt priority.
     69          
     70          **********************************************************************************************************************/
     71          
     72          #include "configuration.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable16  ;; 0xe000e100
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_DisableIRQ(IRQn_Type)
   \                     NVIC_DisableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable16_1  ;; 0xe000e180
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_ClearPendingIRQ(IRQn_Type)
   \                     NVIC_ClearPendingIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x.... 0x....      LDR.W    R2,??DataTable16_2  ;; 0xe000e280
   \   0000000C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000E   0x0943             LSRS     R3,R0,#+5
   \   00000010   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000014   0x4770             BX       LR               ;; return
     73          
     74          
     75          /***********************************************************************************************************************
     76          Global variable definitions with scope across entire project.
     77          All Global variable names shall start with "G_<type>Uart"
     78          ***********************************************************************************************************************/
     79          /* New variables */

   \                                 In section .bss, align 4
     80          u32 G_u32UartApplicationFlags;                    /* Status flags meant for application using this UART peripheral */
   \                     G_u32UartApplicationFlags:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     81          u32 G_u32Uart0ApplicationFlags;                   /* Status flags meant for application using this UART peripheral */
   \                     G_u32Uart0ApplicationFlags:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     82          u32 G_u32Uart1ApplicationFlags;                   /* Status flags meant for application using this UART peripheral */
   \                     G_u32Uart1ApplicationFlags:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
     83          u32 G_u32Uart2ApplicationFlags;                   /* Status flags meant for application using this UART peripheral */
   \                     G_u32Uart2ApplicationFlags:
   \   00000000                      DS8 4
     84          
     85          
     86          /*--------------------------------------------------------------------------------------------------------------------*/
     87          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     88          extern volatile u32 G_u32SystemTime1ms;        /* From board-specific source file */
     89          extern volatile u32 G_u32SystemTime1s;         /* From board-specific source file */
     90          
     91          extern volatile u32 G_u32SystemFlags;          /* From main.c */
     92          extern volatile u32 G_u32ApplicationFlags;     /* From main.c */
     93          
     94          
     95          /***********************************************************************************************************************
     96          Global variable definitions with scope limited to this local application.
     97          Variable names shall start with "UART_" and be declared as static.
     98          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     99          static fnCode_type Uart_pfnStateMachine;        /* The UART application state machine function pointer */
   \                     Uart_pfnStateMachine:
   \   00000000                      DS8 4
    100          

   \                                 In section .bss, align 4
    101          static u32 UART_u32Timer;                       /* Counter used across states */
   \                     UART_u32Timer:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    102          static u32 UART_u32Flags;                       /* Application flags for UART */
   \                     UART_u32Flags:
   \   00000000                      DS8 4

   \                                 In section .bss, align 1
    103          static u8 UART_u8ActiveUarts = 0;               /* Counting semaphore for # of active UARTs */
   \                     UART_u8ActiveUarts:
   \   00000000                      DS8 1
    104          

   \                                 In section .bss, align 4
    105          static UartPeripheralType UART_Peripheral;      /* UART peripheral object */
   \                     UART_Peripheral:
   \   00000000                      DS8 36

   \                                 In section .bss, align 4
    106          static UartPeripheralType UART_Peripheral0;     /* USART0 peripheral object (used as UART) */
   \                     UART_Peripheral0:
   \   00000000                      DS8 36

   \                                 In section .bss, align 4
    107          static UartPeripheralType UART_Peripheral1;     /* USART1 peripheral object (used as UART) */
   \                     UART_Peripheral1:
   \   00000000                      DS8 36

   \                                 In section .bss, align 4
    108          static UartPeripheralType UART_Peripheral2;     /* USART2 peripheral object (used as UART) */
   \                     UART_Peripheral2:
   \   00000000                      DS8 36
    109          

   \                                 In section .bss, align 4
    110          static UartPeripheralType* UART_psCurrentUart;   /* Current UART peripheral being processed */
   \                     UART_psCurrentUart:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    111          static UartPeripheralType* UART_psCurrentISR;    /* Current UART peripheral being processed in ISR */
   \                     UART_psCurrentISR:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    112          static u32* UART_pu32ApplicationFlagsISR;        /* Current UART application status flags in ISR */
   \                     UART_pu32ApplicationFlagsISR:
   \   00000000                      DS8 4
    113          
    114          /* Buffers for simple UART implementation */
    115          #if USE_SIMPLE_USART0
    116          static u8  UART_au8U0RxBuffer[U0RX_BUFFER_SIZE];/* Receive buffer for basic UART0 */
    117          static u8* UART_pu8U0RxBufferNextChar;          /* Pointer to location where next incoming char should be written */
    118          static u8* UART_pu8U0RxBufferUnreadChar;        /* Pointer to location of next char that has not yet been read */
    119          
    120          static u8  UART_au8U0TxBuffer[U0TX_BUFFER_SIZE];/* Transmit buffer for basic UART0 */
    121          static u8* UART_pu8U0TxBufferNextChar;          /* Pointer to location where next outgoing char should be written */
    122          static u8* UART_pu8U0TxBufferUnsentChar;        /* Pointer to location of next char that has not yet been sent */
    123          #endif /* USE_SIMPLE_USART0 */
    124          

   \                                 In section .bss, align 4
    125          static u32 UART_u32IntCount = 0;                /* Debug counter for UART interrupts */
   \                     UART_u32IntCount:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    126          static u32 UART_u32Int0Count = 0;               /* Debug counter for USART0 interrupts */
   \                     UART_u32Int0Count:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    127          static u32 UART_u32Int1Count = 0;               /* Debug counter for USART1 interrupts */
   \                     UART_u32Int1Count:
   \   00000000                      DS8 4

   \                                 In section .bss, align 4
    128          static u32 UART_u32Int2Count = 0;               /* Debug counter for USART2 interrupts */
   \                     UART_u32Int2Count:
   \   00000000                      DS8 4
    129          
    130          
    131          /***********************************************************************************************************************
    132          Function Definitions
    133          ***********************************************************************************************************************/
    134          /*--------------------------------------------------------------------------------------------------------------------*/
    135          /* Public Functions */
    136          /*--------------------------------------------------------------------------------------------------------------------*/
    137          
    138          #if USE_SIMPLE_USART0
    139          
    140          /*----------------------------------------------------------------------------------------------------------------------
    141          Function: Uart_putc
    142          
    143          Description:
    144          Writes a char directly to the debug UART transmit buffer.
    145          
    146          Requires:
    147            - Debug UART is set up
    148          
    149          Promises:
    150            - Character is written directly to the UART buffer if transmitter is ready
    151            - Returns TRUE if character queued to transmit buffer; else returns FALSE
    152          */
    153          bool Uart_putc(u8 u8Char_)
    154          {
    155            /* Check if the transmitter is available */
    156            if(AT91C_BASE_US0->US_CSR & AT91C_US_TXRDY)
    157            {
    158              /* Load the character to send it */
    159              AT91C_BASE_US0->US_THR = u8Char_;    
    160              return TRUE;
    161            }
    162            else
    163            {
    164              /* Transmitter not ready: return FALSE */
    165              return FALSE;
    166            }
    167            
    168          } /* end Uart_putc() */
    169          
    170          
    171          /*----------------------------------------------------------------------------------------------------------------------
    172          Function: Uart_getc
    173          
    174          Description:
    175          Reads a char directly to the debug UART transmit buffer.
    176          Recommended that user first calls UartCheckForNewChar to ensure there is a valid character ready.
    177          
    178          Requires:
    179            - Debug UART is set up
    180          
    181          Promises:
    182            - If there is at least 1 new character, the oldest character from the UART is loaded to pu8Byte and function returns TRUE
    183            - If there are no new characters, pu8Byte_ is untouched and function returns FALSE.
    184          */
    185          bool Uart_getc(u8* pu8Byte_)
    186          {
    187            /* Check if there is at least one new character in the buffer */
    188            if( UartCheckForNewChar() )
    189            {
    190              /* Read the oldest unread character */
    191              *pu8Byte_ = *UART_pu8U0RxBufferUnreadChar;
    192          
    193              /* Safely advance the pointer */
    194              UART_pu8U0RxBufferUnreadChar++;
    195              if(UART_pu8U0RxBufferUnreadChar == &UART_au8U0RxBuffer[U0RX_BUFFER_SIZE])
    196              {
    197                UART_pu8U0RxBufferUnreadChar = &UART_au8U0RxBuffer[0];
    198              }
    199            }
    200            else
    201            {
    202              return FALSE;
    203            }
    204            
    205            return TRUE;
    206            
    207          } /* end Uart_getc() */
    208          
    209          
    210          /*----------------------------------------------------------------------------------------------------------------------
    211          Function: UartCheckForNewChar
    212          
    213          Description:
    214          Checks to see if any new characters are present in the UART debug receive buffer.
    215          
    216          Requires:
    217            - Debug UART is set up
    218          
    219          Promises:
    220            - Returns TRUE if there are new chars ready in the debug UART rx buffer; otherwise
    221              returns FALSE
    222          */
    223          bool UartCheckForNewChar(void)
    224          {
    225            if(UART_pu8U0RxBufferNextChar == UART_pu8U0RxBufferUnreadChar)
    226            {
    227              return(FALSE);
    228            }
    229            else
    230            {
    231              return(TRUE);
    232            }
    233            
    234          } /* end UartCheckForNewChar() */
    235          
    236          #endif /* USE_SIMPLE_USART0 */
    237          
    238          /*----------------------------------------------------------------------------------------------------------------------
    239          Function: UartRequest
    240          
    241          Description:
    242          Requests access to a UART resource.  If the resource is available, the transmit and receive parameters are set up
    243          and the peripheral is made ready to use in the application.  
    244          
    245          Requires:
    246            - UART_Peripheralx perihperal objects have been initialized
    247            - USART Peripheralx registers are not write-protected (WPEN)
    248            - UART peripheral register initialization values in configuration.h must be set correctly
    249            - psUartConfig_ has the UART peripheral number, address of the RxBuffer, and the RxBuffer size and the calling
    250              application is ready to start using the peripheral.
    251            - UART/USART peripheral registers configured here are available and at the same address offset regardless of the peripheral. 
    252          
    253          Promises:
    254            - Returns NULL if a resource cannot be assigned; OR
    255            - Returns a pointer to the requested UART peripheral object if the resource is available
    256            - Peripheral is configured and enabled 
    257            - Peripheral interrupts are enabled.
    258          */

   \                                 In section .text, align 2, keep-with-next
    259          UartPeripheralType* UartRequest(UartConfigurationType* psUartConfig_)
    260          {
   \                     UartRequest: (+1)
   \   00000000   0xE92D 0x47F0      PUSH     {R4-R10,LR}
   \   00000004   0x0004             MOVS     R4,R0
    261            UartPeripheralType* psRequestedUart;
    262            u32 u32TargetCR, u32TargetMR, u32TargetIER, u32TargetIDR, u32TargetBRGR;
    263            
    264            switch(psUartConfig_->UartPeripheral)
   \   00000006   0x7820             LDRB     R0,[R4, #+0]
   \   00000008   0x2801             CMP      R0,#+1
   \   0000000A   0xD006             BEQ.N    ??UartRequest_0
   \   0000000C   0xD346             BCC.N    ??UartRequest_1
   \   0000000E   0x2803             CMP      R0,#+3
   \   00000010   0xD023             BEQ.N    ??UartRequest_2
   \   00000012   0xD312             BCC.N    ??UartRequest_3
   \   00000014   0x2804             CMP      R0,#+4
   \   00000016   0xD030             BEQ.N    ??UartRequest_4
   \   00000018   0xE040             B.N      ??UartRequest_1
    265            {
    266              case UART:
    267              {
    268                psRequestedUart = &UART_Peripheral; 
   \                     ??UartRequest_0: (+1)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable16_3
   \   0000001E   0x0005             MOVS     R5,R0
    269          
    270                u32TargetCR   = UART_US_CR_INIT;
   \   00000020   0x2050             MOVS     R0,#+80
   \   00000022   0x0006             MOVS     R6,R0
    271                u32TargetMR   = UART_US_MR_INIT; 
   \   00000024   0x.... 0x....      LDR.W    R0,??DataTable16_4  ;; 0x4008c0
   \   00000028   0x0007             MOVS     R7,R0
    272                u32TargetIER  = UART_US_IER_INIT; 
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x4680             MOV      R8,R0
    273                u32TargetIDR  = UART_US_IDR_INIT;
   \   0000002E   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000032   0x4681             MOV      R9,R0
    274                u32TargetBRGR = UART_US_BRGR_INIT;
   \   00000034   0x201A             MOVS     R0,#+26
   \   00000036   0x4682             MOV      R10,R0
    275                break;
   \   00000038   0xE032             B.N      ??UartRequest_5
    276              } 
    277          
    278              case USART0:
    279              {
    280                psRequestedUart = &UART_Peripheral0; 
   \                     ??UartRequest_3: (+1)
   \   0000003A   0x.... 0x....      LDR.W    R0,??DataTable16_5
   \   0000003E   0x0005             MOVS     R5,R0
    281          
    282                u32TargetCR   = USART0_US_CR_INIT;
   \   00000040   0x2050             MOVS     R0,#+80
   \   00000042   0x0006             MOVS     R6,R0
    283                u32TargetMR   = USART0_US_MR_INIT; 
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable16_4  ;; 0x4008c0
   \   00000048   0x0007             MOVS     R7,R0
    284                u32TargetIER  = USART0_US_IER_INIT; 
   \   0000004A   0x2008             MOVS     R0,#+8
   \   0000004C   0x4680             MOV      R8,R0
    285                u32TargetIDR  = USART0_US_IDR_INIT;
   \   0000004E   0xF07F 0x0008      MVNS     R0,#+8
   \   00000052   0x4681             MOV      R9,R0
    286                u32TargetBRGR = USART0_US_BRGR_INIT;
   \   00000054   0x201A             MOVS     R0,#+26
   \   00000056   0x4682             MOV      R10,R0
    287                break;
   \   00000058   0xE022             B.N      ??UartRequest_5
    288              } 
    289          
    290              case USART1:
    291              {
    292                psRequestedUart = &UART_Peripheral1; 
   \                     ??UartRequest_2: (+1)
   \   0000005A   0x.... 0x....      LDR.W    R0,??DataTable16_6
   \   0000005E   0x0005             MOVS     R5,R0
    293          
    294                u32TargetCR   = USART1_US_CR_INIT;
   \   00000060   0x2060             MOVS     R0,#+96
   \   00000062   0x0006             MOVS     R6,R0
    295                u32TargetMR   = USART1_US_MR_INIT; 
   \   00000064   0x.... 0x....      LDR.W    R0,??DataTable16_7  ;; 0x4518ce
   \   00000068   0x0007             MOVS     R7,R0
    296                u32TargetIER  = USART1_US_IER_INIT; 
   \   0000006A   0x2000             MOVS     R0,#+0
   \   0000006C   0x4680             MOV      R8,R0
    297                u32TargetIDR  = USART1_US_IDR_INIT;
   \   0000006E   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000072   0x4681             MOV      R9,R0
    298                u32TargetBRGR = USART1_US_BRGR_INIT;
   \   00000074   0x2030             MOVS     R0,#+48
   \   00000076   0x4682             MOV      R10,R0
    299                break;
   \   00000078   0xE012             B.N      ??UartRequest_5
    300              } 
    301              
    302              case USART2:
    303              {
    304                psRequestedUart = &UART_Peripheral2; 
   \                     ??UartRequest_4: (+1)
   \   0000007A   0x.... 0x....      LDR.W    R0,??DataTable16_8
   \   0000007E   0x0005             MOVS     R5,R0
    305                
    306                u32TargetCR   = USART2_US_CR_INIT;
   \   00000080   0x2050             MOVS     R0,#+80
   \   00000082   0x0006             MOVS     R6,R0
    307                u32TargetMR   = USART2_US_MR_INIT; 
   \   00000084   0x.... 0x....      LDR.W    R0,??DataTable16_9  ;; 0x4118ff
   \   00000088   0x0007             MOVS     R7,R0
    308                u32TargetIER  = USART2_US_IER_INIT; 
   \   0000008A   0xF45F 0x2000      MOVS     R0,#+524288
   \   0000008E   0x4680             MOV      R8,R0
    309                u32TargetIDR  = USART2_US_IDR_INIT;
   \   00000090   0xF05F 0x30FF      MOVS     R0,#-1
   \   00000094   0x4681             MOV      R9,R0
    310                u32TargetBRGR = USART2_US_BRGR_INIT;
   \   00000096   0x2000             MOVS     R0,#+0
   \   00000098   0x4682             MOV      R10,R0
    311                break;
   \   0000009A   0xE001             B.N      ??UartRequest_5
    312              } 
    313          
    314              default:
    315              {
    316                return(NULL);
   \                     ??UartRequest_1: (+1)
   \   0000009C   0x2000             MOVS     R0,#+0
   \   0000009E   0xE049             B.N      ??UartRequest_6
    317                break;
    318              } 
    319            } /* end switch */
    320          
    321            /* If the requested peripheral is already assigned, return NULL now */
    322            if(psRequestedUart->u32PrivateFlags & _UART_PERIPHERAL_ASSIGNED)
   \                     ??UartRequest_5: (+1)
   \   000000A0   0x7928             LDRB     R0,[R5, #+4]
   \   000000A2   0x07C0             LSLS     R0,R0,#+31
   \   000000A4   0xD501             BPL.N    ??UartRequest_7
    323            {
    324              return(NULL);
   \   000000A6   0x2000             MOVS     R0,#+0
   \   000000A8   0xE044             B.N      ??UartRequest_6
    325            }
    326            
    327            /* Activate and configure the peripheral */
    328            AT91C_BASE_PMC->PMC_PCER |= (1 << psRequestedUart->u8PeripheralId);
   \                     ??UartRequest_7: (+1)
   \   000000AA   0x.... 0x....      LDR.W    R0,??DataTable16_10  ;; 0x400e0410
   \   000000AE   0x6800             LDR      R0,[R0, #+0]
   \   000000B0   0x2101             MOVS     R1,#+1
   \   000000B2   0xF995 0x2022      LDRSB    R2,[R5, #+34]
   \   000000B6   0x4091             LSLS     R1,R1,R2
   \   000000B8   0x4308             ORRS     R0,R1,R0
   \   000000BA   0x.... 0x....      LDR.W    R1,??DataTable16_10  ;; 0x400e0410
   \   000000BE   0x6008             STR      R0,[R1, #+0]
    329          
    330            psRequestedUart->pu8RxBuffer     = psUartConfig_->pu8RxBufferAddress;
   \   000000C0   0x6860             LDR      R0,[R4, #+4]
   \   000000C2   0x6168             STR      R0,[R5, #+20]
    331            psRequestedUart->u16RxBufferSize = psUartConfig_->u16RxBufferSize;
   \   000000C4   0x8860             LDRH     R0,[R4, #+2]
   \   000000C6   0x8428             STRH     R0,[R5, #+32]
    332            psRequestedUart->pu8RxNextByte   = psUartConfig_->pu8RxNextByte;
   \   000000C8   0x68A0             LDR      R0,[R4, #+8]
   \   000000CA   0x61A8             STR      R0,[R5, #+24]
    333            psRequestedUart->fnRxCallback    = psUartConfig_->fnRxCallback;
   \   000000CC   0x68E0             LDR      R0,[R4, #+12]
   \   000000CE   0x61E8             STR      R0,[R5, #+28]
    334            psRequestedUart->u32PrivateFlags |= _UART_PERIPHERAL_ASSIGNED;
   \   000000D0   0x6868             LDR      R0,[R5, #+4]
   \   000000D2   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   000000D6   0x6068             STR      R0,[R5, #+4]
    335            
    336            psRequestedUart->pBaseAddress->US_CR   = u32TargetCR;
   \   000000D8   0x6828             LDR      R0,[R5, #+0]
   \   000000DA   0x6006             STR      R6,[R0, #+0]
    337            psRequestedUart->pBaseAddress->US_MR   = u32TargetMR;
   \   000000DC   0x6828             LDR      R0,[R5, #+0]
   \   000000DE   0x6047             STR      R7,[R0, #+4]
    338            psRequestedUart->pBaseAddress->US_IER  = u32TargetIER;
   \   000000E0   0x6828             LDR      R0,[R5, #+0]
   \   000000E2   0xF8C0 0x8008      STR      R8,[R0, #+8]
    339            psRequestedUart->pBaseAddress->US_IDR  = u32TargetIDR;
   \   000000E6   0x6828             LDR      R0,[R5, #+0]
   \   000000E8   0xF8C0 0x900C      STR      R9,[R0, #+12]
    340            psRequestedUart->pBaseAddress->US_BRGR = u32TargetBRGR;
   \   000000EC   0x6828             LDR      R0,[R5, #+0]
   \   000000EE   0xF8C0 0xA020      STR      R10,[R0, #+32]
    341          
    342            /* Preset the receive PDC pointers and counters; the receive buffer must be starting from [0] and be at least 2 bytes long)*/
    343            psRequestedUart->pBaseAddress->US_RPR  = (unsigned int)psUartConfig_->pu8RxBufferAddress;
   \   000000F2   0x6860             LDR      R0,[R4, #+4]
   \   000000F4   0x6829             LDR      R1,[R5, #+0]
   \   000000F6   0xF8C1 0x0100      STR      R0,[R1, #+256]
    344            psRequestedUart->pBaseAddress->US_RNPR = (unsigned int)((psUartConfig_->pu8RxBufferAddress) + 1);
   \   000000FA   0x6860             LDR      R0,[R4, #+4]
   \   000000FC   0x1C40             ADDS     R0,R0,#+1
   \   000000FE   0x6829             LDR      R1,[R5, #+0]
   \   00000100   0xF8C1 0x0110      STR      R0,[R1, #+272]
    345            psRequestedUart->pBaseAddress->US_RCR  = 1;
   \   00000104   0x2001             MOVS     R0,#+1
   \   00000106   0x6829             LDR      R1,[R5, #+0]
   \   00000108   0xF8C1 0x0104      STR      R0,[R1, #+260]
    346            psRequestedUart->pBaseAddress->US_RNCR = 1;
   \   0000010C   0x2001             MOVS     R0,#+1
   \   0000010E   0x6829             LDR      R1,[R5, #+0]
   \   00000110   0xF8C1 0x0114      STR      R0,[R1, #+276]
    347            
    348            /* Enable the receiver and transmitter requests */
    349            psRequestedUart->pBaseAddress->US_PTCR = AT91C_PDC_RXTEN | AT91C_PDC_TXTEN;
   \   00000114   0xF240 0x1001      MOVW     R0,#+257
   \   00000118   0x6829             LDR      R1,[R5, #+0]
   \   0000011A   0xF8C1 0x0120      STR      R0,[R1, #+288]
    350          
    351            /* Enable UART interrupts */
    352            NVIC_ClearPendingIRQ( (IRQn_Type)psRequestedUart->u8PeripheralId );
   \   0000011E   0xF995 0x0022      LDRSB    R0,[R5, #+34]
   \   00000122   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000124   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    353            NVIC_EnableIRQ( (IRQn_Type)psRequestedUart->u8PeripheralId );
   \   00000128   0xF995 0x0022      LDRSB    R0,[R5, #+34]
   \   0000012C   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000012E   0x.... 0x....      BL       NVIC_EnableIRQ
    354            
    355            return(psRequestedUart);
   \   00000132   0x0028             MOVS     R0,R5
   \                     ??UartRequest_6: (+1)
   \   00000134   0xE8BD 0x87F0      POP      {R4-R10,PC}      ;; return
    356            
    357          } /* end UartRequest() */
    358          
    359          
    360          /*----------------------------------------------------------------------------------------------------------------------
    361          Function: UartRelease
    362          
    363          Description:
    364          Releases a UART resource.  
    365          
    366          Requires:
    367            - psUartPeripheral_ has the UART peripheral number, address of the RxBuffer, and the RxBuffer size and the calling
    368              application is ready to start using the peripheral.
    369          
    370          Promises:
    371            - Resets peripheral object's pointers and data to safe values
    372            - Peripheral is disabled
    373            - Peripheral interrupts are disabled.
    374          */

   \                                 In section .text, align 2, keep-with-next
    375          void UartRelease(UartPeripheralType* psUartPeripheral_)
    376          {
   \                     UartRelease: (+1)
   \   00000000   0xB510             PUSH     {R4,LR}
   \   00000002   0x0004             MOVS     R4,R0
    377            /* Check to see if the peripheral is already released */
    378            if(psUartPeripheral_->pu8RxBuffer == NULL)
   \   00000004   0x6960             LDR      R0,[R4, #+20]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD023             BEQ.N    ??UartRelease_0
    379            {
    380              return;
    381            }
    382            
    383            /* First disable the interrupts */
    384            NVIC_DisableIRQ( (IRQn_Type)(psUartPeripheral_->u8PeripheralId) );
   \                     ??UartRelease_1: (+1)
   \   0000000A   0xF994 0x0022      LDRSB    R0,[R4, #+34]
   \   0000000E   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   00000010   0x.... 0x....      BL       NVIC_DisableIRQ
    385            NVIC_ClearPendingIRQ( (IRQn_Type)(psUartPeripheral_->u8PeripheralId) );
   \   00000014   0xF994 0x0022      LDRSB    R0,[R4, #+34]
   \   00000018   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000001A   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    386           
    387            /* Now it's safe to release all of the resources in the target peripheral */
    388            psUartPeripheral_->pu8RxBuffer    = NULL;
   \   0000001E   0x2000             MOVS     R0,#+0
   \   00000020   0x6160             STR      R0,[R4, #+20]
    389            psUartPeripheral_->pu8RxNextByte  = NULL;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x61A0             STR      R0,[R4, #+24]
    390            psUartPeripheral_->fnRxCallback   = NULL;
   \   00000026   0x2000             MOVS     R0,#+0
   \   00000028   0x61E0             STR      R0,[R4, #+28]
    391            psUartPeripheral_->u32PrivateFlags = 0;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x6060             STR      R0,[R4, #+4]
    392          
    393            /* Empty the transmit buffer if there were leftover messages */
    394            while(psUartPeripheral_->psTransmitBuffer != NULL)
   \                     ??UartRelease_2: (+1)
   \   0000002E   0x68A0             LDR      R0,[R4, #+8]
   \   00000030   0x2800             CMP      R0,#+0
   \   00000032   0xD009             BEQ.N    ??UartRelease_3
    395            {
    396              UpdateMessageStatus(psUartPeripheral_->psTransmitBuffer->u32Token, ABANDONED);
   \   00000034   0x2106             MOVS     R1,#+6
   \   00000036   0x68A0             LDR      R0,[R4, #+8]
   \   00000038   0x6800             LDR      R0,[R0, #+0]
   \   0000003A   0x.... 0x....      BL       UpdateMessageStatus
    397              DeQueueMessage(&psUartPeripheral_->psTransmitBuffer);
   \   0000003E   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000042   0x.... 0x....      BL       DeQueueMessage
   \   00000046   0xE7F2             B.N      ??UartRelease_2
    398            }
    399            
    400            /* Ensure the SM is in the Idle state */
    401            Uart_pfnStateMachine = UartSM_Idle;
   \                     ??UartRelease_3: (+1)
   \   00000048   0x.... 0x....      ADR.W    R0,UartSM_Idle
   \   0000004C   0x.... 0x....      LDR.W    R1,??DataTable16_11
   \   00000050   0x6008             STR      R0,[R1, #+0]
    402           
    403          } /* end UartRelease() */
   \                     ??UartRelease_0: (+1)
   \   00000052   0xBD10             POP      {R4,PC}          ;; return
    404          
    405          
    406          /*----------------------------------------------------------------------------------------------------------------------
    407          Function: UartWriteByte
    408          
    409          Description:
    410          Queues a single byte for transfer on the target UART peripheral.  
    411          
    412          Requires:
    413            - psUartPeripheral_ has been requested.
    414          
    415          Promises:
    416            - Creates a 1-byte message at psUartPeripheral_->pTransmitBuffer that will be sent by the UART application
    417              when it is available.
    418            - Returns the message token assigned to the message
    419          */

   \                                 In section .text, align 2, keep-with-next
    420          u32 UartWriteByte(UartPeripheralType* psUartPeripheral_, u8 u8Byte_)
    421          {
   \                     UartWriteByte: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0xB082             SUB      SP,SP,#+8
   \   00000004   0x0004             MOVS     R4,R0
   \   00000006   0x000D             MOVS     R5,R1
    422            u32 u32Token;
    423            u8 u8Data = u8Byte_;
   \   00000008   0xF88D 0x5000      STRB     R5,[SP, #+0]
    424            
    425            u32Token = QueueMessage(&psUartPeripheral_->psTransmitBuffer, 1, &u8Data);
   \   0000000C   0xAA00             ADD      R2,SP,#+0
   \   0000000E   0x2101             MOVS     R1,#+1
   \   00000010   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000014   0x.... 0x....      BL       QueueMessage
   \   00000018   0x0006             MOVS     R6,R0
    426            if( u32Token != 0 )
   \   0000001A   0x2E00             CMP      R6,#+0
   \   0000001C   0xD006             BEQ.N    ??UartWriteByte_0
    427            {
    428              /* If the system is initializing, we want to manually cycle the UART task through one iteration
    429              to send the message */
    430              if(G_u32SystemFlags & _SYSTEM_INITIALIZING)
   \   0000001E   0x.... 0x....      LDR.W    R0,??DataTable16_12
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0x2800             CMP      R0,#+0
   \   00000026   0xD501             BPL.N    ??UartWriteByte_0
    431              {
    432                UartManualMode();
   \   00000028   0x.... 0x....      BL       UartManualMode
    433              }
    434            }
    435            
    436            return(u32Token);
   \                     ??UartWriteByte_0: (+1)
   \   0000002C   0x0030             MOVS     R0,R6
   \   0000002E   0xBD76             POP      {R1,R2,R4-R6,PC}  ;; return
    437            
    438          } /* end UartWriteByte() */
    439          
    440          
    441          /*----------------------------------------------------------------------------------------------------------------------
    442          Function: UartWriteData
    443          
    444          Description:
    445          Queues a data array for transfer on the target UART peripheral.  
    446          
    447          Requires:
    448            - psUartPeripheral_ has been requested and holds a valid pointer to a transmit buffer; even if a transmission is
    449              in progress, the node in the buffer that is currently being sent will not be destroyed during this function.
    450            - u32Size_ is the number of bytes in the data array
    451            - u8Data_ points to the first byte of the data array
    452          
    453          Promises:
    454            - adds the data message at psUartPeripheral_->pTransmitBuffer that will be sent by the UART application
    455              when it is available.
    456            - Returns the message token assigned to the message; 0 is returned if the message cannot be queued in which case
    457              G_u32MessagingFlags can be checked for the reason
    458          */

   \                                 In section .text, align 2, keep-with-next
    459          u32 UartWriteData(UartPeripheralType* psUartPeripheral_, u32 u32Size_, u8* u8Data_)
    460          {
   \                     UartWriteData: (+1)
   \   00000000   0xB5F8             PUSH     {R3-R7,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
   \   00000006   0x0016             MOVS     R6,R2
    461            u32 u32Token;
    462          
    463            u32Token = QueueMessage(&psUartPeripheral_->psTransmitBuffer, u32Size_, u8Data_);
   \   00000008   0x0032             MOVS     R2,R6
   \   0000000A   0x0029             MOVS     R1,R5
   \   0000000C   0xF114 0x0008      ADDS     R0,R4,#+8
   \   00000010   0x.... 0x....      BL       QueueMessage
   \   00000014   0x0007             MOVS     R7,R0
    464            if(u32Token)
   \   00000016   0x2F00             CMP      R7,#+0
   \   00000018   0xD006             BEQ.N    ??UartWriteData_0
    465            {
    466              /* If the system is initializing, manually cycle the UART task through one iteration to send the message */
    467              if(G_u32SystemFlags & _SYSTEM_INITIALIZING)
   \   0000001A   0x.... 0x....      LDR.W    R0,??DataTable16_12
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x2800             CMP      R0,#+0
   \   00000022   0xD501             BPL.N    ??UartWriteData_0
    468              {
    469                UartManualMode();
   \   00000024   0x.... 0x....      BL       UartManualMode
    470              }
    471            }
    472            
    473            return(u32Token);
   \                     ??UartWriteData_0: (+1)
   \   00000028   0x0038             MOVS     R0,R7
   \   0000002A   0xBDF2             POP      {R1,R4-R7,PC}    ;; return
    474            
    475          } /* end UartWriteData() */
    476          
    477          
    478          /*--------------------------------------------------------------------------------------------------------------------*/
    479          /* Protected Functions */
    480          /*--------------------------------------------------------------------------------------------------------------------*/
    481          
    482          /*----------------------------------------------------------------------------------------------------------------------
    483          Function: UartInitialize
    484          
    485          Description:
    486          Initializes the UART application and its variables.  UART0 is setup to be available immediately for debugging
    487          purposes.  The generic peripherals themselves are not fully configured until requested by a calling application.
    488          
    489          Requires:
    490            - 
    491          
    492          Promises:
    493            - UART peripheral objects are ready 
    494            - UART application set to Idle
    495          */

   \                                 In section .text, align 2, keep-with-next
    496          void UartInitialize(void)
    497          {
    498            UART_u32Flags = 0;
   \                     UartInitialize: (+1)
   \   00000000   0x2000             MOVS     R0,#+0
   \   00000002   0x.... 0x....      LDR.W    R1,??DataTable16_13
   \   00000006   0x6008             STR      R0,[R1, #+0]
    499          
    500          #ifdef USE_SIMPLE_USART0
    501            /* Setup USART0 for use as a basic debug port */
    502            
    503            /* Initialize pointers and clear the receive buffer */
    504            UART_pu8U0RxBufferNextChar   = &UART_au8U0RxBuffer[0];
    505            UART_pu8U0RxBufferUnreadChar = &UART_au8U0RxBuffer[0];
    506            for(u16 i = 0; i < U0RX_BUFFER_SIZE; i++)
    507            {
    508              UART_au8U0RxBuffer[i] = 0;
    509            }
    510          
    511            UART_pu8U0TxBufferNextChar   = &UART_au8U0TxBuffer[0];
    512            UART_pu8U0TxBufferUnsentChar = &UART_au8U0TxBuffer[0];
    513            for(u16 i = 0; i < U0TX_BUFFER_SIZE; i++)
    514            {
    515              UART_au8U0TxBuffer[i] = 0;
    516            }
    517            
    518            /* Activate the US0 clock and set peripheral configuration registers */
    519            AT91C_BASE_PMC->PMC_PCER |= (1 << AT91C_ID_US0);
    520            
    521            AT91C_BASE_US0->US_CR   = USART0_US_CR_INIT;
    522            AT91C_BASE_US0->US_MR   = USART0_US_MR_INIT;
    523            AT91C_BASE_US0->US_IER  = USART0_US_IER_INIT;
    524            AT91C_BASE_US0->US_IDR  = USART0_US_IDR_INIT;
    525            AT91C_BASE_US0->US_BRGR = USART0_US_BRGR_INIT;
    526          
    527            /* Enable U0 interrupts */
    528            NVIC_ClearPendingIRQ(IRQn_US0);
    529            NVIC_EnableIRQ(IRQn_US0);
    530          
    531            /* Print the startup message */
    532            UART_u32Timer = G_u32SystemTime1ms;
    533            pu8Parser = &au8Uart0StartupMsg[0];
    534            while(*pu8Parser != NULL)
    535            {
    536              /* Attempt to queue the character */
    537              if( Uart_putc(*pu8Parser) )
    538              {
    539                /* Advance only if character has been sent */
    540                pu8Parser++;
    541              }
    542                 
    543              /* Watch for timeout */
    544              if( IsTimeUp(&UART_u32Timer, UART_INIT_MSG_TIMEOUT) )
    545              {
    546                break;
    547              }
    548            }
    549          
    550          #if 0
    551            DebugPrintf(au8Uart0StartupMsg);
    552            while(UART_pu8U0TxBufferUnsentChar != UART_pu8U0TxBufferNextChar)
    553            {
    554              UartManualMode();
    555            }
    556          #endif
    557            
    558          #endif /* USE_SIMPLE_USART0 */
    559            
    560            /* Setup generic UARTs */
    561            
    562            /* Initialize the UART peripheral structures */
    563            UART_Peripheral.pBaseAddress     = (AT91S_USART*)AT91C_BASE_DBGU;
   \   00000008   0x.... 0x....      LDR.W    R0,??DataTable16_14  ;; 0x400e0600
   \   0000000C   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \   00000010   0x6008             STR      R0,[R1, #+0]
    564            UART_Peripheral.psTransmitBuffer = NULL;
   \   00000012   0x2000             MOVS     R0,#+0
   \   00000014   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \   00000018   0x6088             STR      R0,[R1, #+8]
    565            UART_Peripheral.pu8RxBuffer      = NULL;
   \   0000001A   0x2000             MOVS     R0,#+0
   \   0000001C   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \   00000020   0x6148             STR      R0,[R1, #+20]
    566            UART_Peripheral.u16RxBufferSize  = 0;
   \   00000022   0x2000             MOVS     R0,#+0
   \   00000024   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \   00000028   0x8408             STRH     R0,[R1, #+32]
    567            UART_Peripheral.pu8RxNextByte    = NULL;
   \   0000002A   0x2000             MOVS     R0,#+0
   \   0000002C   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \   00000030   0x6188             STR      R0,[R1, #+24]
    568            UART_Peripheral.u32PrivateFlags  = 0;
   \   00000032   0x2000             MOVS     R0,#+0
   \   00000034   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \   00000038   0x6048             STR      R0,[R1, #+4]
    569            UART_Peripheral.u8PeripheralId  = AT91C_ID_DBGU;
   \   0000003A   0x2008             MOVS     R0,#+8
   \   0000003C   0x.... 0x....      LDR.W    R1,??DataTable16_3
   \   00000040   0xF881 0x0022      STRB     R0,[R1, #+34]
    570          
    571            UART_Peripheral0.pBaseAddress    = AT91C_BASE_US0;
   \   00000044   0x.... 0x....      LDR.W    R0,??DataTable16_15  ;; 0x40090000
   \   00000048   0x.... 0x....      LDR.W    R1,??DataTable16_5
   \   0000004C   0x6008             STR      R0,[R1, #+0]
    572            UART_Peripheral0.psTransmitBuffer = NULL;
   \   0000004E   0x2000             MOVS     R0,#+0
   \   00000050   0x.... 0x....      LDR.W    R1,??DataTable16_5
   \   00000054   0x6088             STR      R0,[R1, #+8]
    573            UART_Peripheral0.pu8RxBuffer     = NULL;
   \   00000056   0x2000             MOVS     R0,#+0
   \   00000058   0x.... 0x....      LDR.W    R1,??DataTable16_5
   \   0000005C   0x6148             STR      R0,[R1, #+20]
    574            UART_Peripheral0.u16RxBufferSize = 0;
   \   0000005E   0x2000             MOVS     R0,#+0
   \   00000060   0x.... 0x....      LDR.W    R1,??DataTable16_5
   \   00000064   0x8408             STRH     R0,[R1, #+32]
    575            UART_Peripheral0.pu8RxNextByte   = NULL;
   \   00000066   0x2000             MOVS     R0,#+0
   \   00000068   0x.... 0x....      LDR.W    R1,??DataTable16_5
   \   0000006C   0x6188             STR      R0,[R1, #+24]
    576            UART_Peripheral0.u32PrivateFlags = 0;
   \   0000006E   0x2000             MOVS     R0,#+0
   \   00000070   0x.... 0x....      LDR.W    R1,??DataTable16_5
   \   00000074   0x6048             STR      R0,[R1, #+4]
    577            UART_Peripheral0.u8PeripheralId  = AT91C_ID_US0;
   \   00000076   0x200D             MOVS     R0,#+13
   \   00000078   0x.... 0x....      LDR.W    R1,??DataTable16_5
   \   0000007C   0xF881 0x0022      STRB     R0,[R1, #+34]
    578          
    579            UART_Peripheral1.pBaseAddress    = AT91C_BASE_US1;
   \   00000080   0x.... 0x....      LDR.W    R0,??DataTable16_16  ;; 0x40094000
   \   00000084   0x.... 0x....      LDR.W    R1,??DataTable16_6
   \   00000088   0x6008             STR      R0,[R1, #+0]
    580            UART_Peripheral1.psTransmitBuffer = NULL;
   \   0000008A   0x2000             MOVS     R0,#+0
   \   0000008C   0x.... 0x....      LDR.W    R1,??DataTable16_6
   \   00000090   0x6088             STR      R0,[R1, #+8]
    581            UART_Peripheral1.pu8RxBuffer     = NULL;
   \   00000092   0x2000             MOVS     R0,#+0
   \   00000094   0x.... 0x....      LDR.W    R1,??DataTable16_6
   \   00000098   0x6148             STR      R0,[R1, #+20]
    582            UART_Peripheral1.u16RxBufferSize = 0;
   \   0000009A   0x2000             MOVS     R0,#+0
   \   0000009C   0x.... 0x....      LDR.W    R1,??DataTable16_6
   \   000000A0   0x8408             STRH     R0,[R1, #+32]
    583            UART_Peripheral1.pu8RxNextByte   = NULL;
   \   000000A2   0x2000             MOVS     R0,#+0
   \   000000A4   0x.... 0x....      LDR.W    R1,??DataTable16_6
   \   000000A8   0x6188             STR      R0,[R1, #+24]
    584            UART_Peripheral1.u32PrivateFlags = 0;
   \   000000AA   0x2000             MOVS     R0,#+0
   \   000000AC   0x.... 0x....      LDR.W    R1,??DataTable16_6
   \   000000B0   0x6048             STR      R0,[R1, #+4]
    585            UART_Peripheral1.u8PeripheralId  = AT91C_ID_US1;
   \   000000B2   0x200E             MOVS     R0,#+14
   \   000000B4   0x.... 0x....      LDR.W    R1,??DataTable16_6
   \   000000B8   0xF881 0x0022      STRB     R0,[R1, #+34]
    586          
    587            UART_Peripheral2.pBaseAddress    = AT91C_BASE_US2;
   \   000000BC   0x.... 0x....      LDR.W    R0,??DataTable16_17  ;; 0x40098000
   \   000000C0   0x.... 0x....      LDR.W    R1,??DataTable16_8
   \   000000C4   0x6008             STR      R0,[R1, #+0]
    588            UART_Peripheral2.psTransmitBuffer = NULL;
   \   000000C6   0x2000             MOVS     R0,#+0
   \   000000C8   0x....             LDR.N    R1,??DataTable16_8
   \   000000CA   0x6088             STR      R0,[R1, #+8]
    589            UART_Peripheral2.pu8RxBuffer     = NULL;
   \   000000CC   0x2000             MOVS     R0,#+0
   \   000000CE   0x....             LDR.N    R1,??DataTable16_8
   \   000000D0   0x6148             STR      R0,[R1, #+20]
    590            UART_Peripheral2.u16RxBufferSize = 0;
   \   000000D2   0x2000             MOVS     R0,#+0
   \   000000D4   0x....             LDR.N    R1,??DataTable16_8
   \   000000D6   0x8408             STRH     R0,[R1, #+32]
    591            UART_Peripheral2.pu8RxNextByte   = NULL;
   \   000000D8   0x2000             MOVS     R0,#+0
   \   000000DA   0x....             LDR.N    R1,??DataTable16_8
   \   000000DC   0x6188             STR      R0,[R1, #+24]
    592            UART_Peripheral2.u32PrivateFlags = 0;
   \   000000DE   0x2000             MOVS     R0,#+0
   \   000000E0   0x....             LDR.N    R1,??DataTable16_8
   \   000000E2   0x6048             STR      R0,[R1, #+4]
    593            UART_Peripheral2.u8PeripheralId  = AT91C_ID_US2;
   \   000000E4   0x200F             MOVS     R0,#+15
   \   000000E6   0x....             LDR.N    R1,??DataTable16_8
   \   000000E8   0xF881 0x0022      STRB     R0,[R1, #+34]
    594            
    595            UART_psCurrentUart               = &UART_Peripheral;
   \   000000EC   0x....             LDR.N    R0,??DataTable16_3
   \   000000EE   0x....             LDR.N    R1,??DataTable16_18
   \   000000F0   0x6008             STR      R0,[R1, #+0]
    596          //  UART_u32CurrentTxBytesRemaining  = 0;
    597          //  UART_pu8CurrentTxData            = NULL;
    598          
    599            /* Set application pointer */
    600            Uart_pfnStateMachine = UartSM_Idle;
   \   000000F2   0x.... 0x....      ADR.W    R0,UartSM_Idle
   \   000000F6   0x....             LDR.N    R1,??DataTable16_11
   \   000000F8   0x6008             STR      R0,[R1, #+0]
    601            
    602          } /* end UartInitialize() */
   \   000000FA   0x4770             BX       LR               ;; return
    603          
    604          
    605          /*----------------------------------------------------------------------------------------------------------------------
    606          Function UartRunActiveState()
    607          
    608          Description:
    609          Selects and runs one iteration of the current state in the state machine.
    610          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    611          may take 1ms / n to execute.
    612          
    613          Requires:
    614            - State machine function pointer points at current state
    615          
    616          Promises:
    617            - Calls the function to pointed by the state machine function pointer
    618          */

   \                                 In section .text, align 2, keep-with-next
    619          void UartRunActiveState(void)
    620          {
   \                     UartRunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    621            Uart_pfnStateMachine();
   \   00000002   0x....             LDR.N    R0,??DataTable16_11
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    622          
    623          } /* end UartRunActiveState */
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    624          
    625          
    626          
    627          /*--------------------------------------------------------------------------------------------------------------------*/
    628          /* Private functions */
    629          /*--------------------------------------------------------------------------------------------------------------------*/
    630          
    631          #if 0
    632          /*----------------------------------------------------------------------------------------------------------------------
    633          Function: UartFillTxBuffer
    634          
    635          Description:
    636          Fills the UART peripheral buffer with bytes from the current messsage that is sending.  
    637          This function can be called from the UART ISR!
    638          Note: if the implemented processor does not have a FIFO, this function can still be used but will only ever
    639          add one byte to the transmitter.
    640          
    641          Requires:
    642            - The TxBuffer is empty
    643            - psUartPeripheral_ points to the UART peripheral being used.  
    644            - UART_pu8CurrentTxData points to the next byte in the message to be sent
    645            - UART_u32CurrentTxBytesRemaining has an accurate count of the bytes remaining in the message data to be sent
    646            - Transmit interrupts are off
    647          
    648          Promises:
    649            - Data from *UART_pu8CurrentTxData is added to the UART peripheral Tx FIFO until the FIFO is full or there
    650              is no more data to send.
    651          */
    652          static void UartFillTxBuffer(UartPeripheralType* psUartPeripheral_)
    653          {
    654            u8 u8ByteCount = UART_TX_FIFO_SIZE;
    655            
    656            /* Use the active global variables to fill up the transmit FIFO */
    657            while( (u8ByteCount != 0) && (UART_u32CurrentTxBytesRemaining != 0) )
    658            {
    659              psUartPeripheral_->pBaseAddress->US_THR = *UART_pu8CurrentTxData;
    660              UART_pu8CurrentTxData++;
    661              UART_u32CurrentTxBytesRemaining--;
    662              u8ByteCount--;
    663            }
    664              
    665            /* If there are no remaining bytes to load to the TX FIFO, disable the UART transmit 
    666            FIFO empty interrupt */
    667            if(UART_u32CurrentTxBytesRemaining == 0)
    668            {
    669              psUartPeripheral_->pBaseAddress->US_IDR = AT91C_US_TXEMPTY;
    670            }
    671            /* Otherwise make sure transmit interrupts are enabled */
    672            else
    673            {
    674              psUartPeripheral_->pBaseAddress->US_IER = AT91C_US_TXEMPTY;
    675            }
    676            
    677          } /* end UartFillTxBuffer() */
    678          
    679          
    680          /*----------------------------------------------------------------------------------------------------------------------
    681          Function: UartReadRxBuffer
    682          
    683          Description:
    684          Reads all bytes from the UART peripheral Rx FIFO and places them in the application receive buffer.  
    685          This function is only called from the UART ISR so interrupts will be off.
    686          
    687          Requires:
    688            - UART_pu8CurrentTxData points to the next byte in the message to be sent
    689            - UART_u32CurrentTxBytesRemaining has an accurate count of the bytes remaining in the message data to be sent
    690            - Transmit interrupts are off
    691          
    692          Promises:
    693            - All bytes currently in the UART Rx FIFO are read out to the application receive circular buffer.
    694          */
    695          static void UartReadRxBuffer(UartPeripheralType* psTargetUart_) 
    696          {
    697            u8 u8Test;
    698            
    699            /* Read all the bytes in the Rx FIFO */
    700            while(psTargetUart_->pBaseAddress->US_CSR & AT91C_US_RXRDY)
    701            {
    702              u8Test = psTargetUart_->pBaseAddress->US_RHR;
    703              **(psTargetUart_->pu8RxNextByte) = u8Test; 
    704          
    705              /* Safely advance the pointer in the circular buffer */
    706              (*psTargetUart_->pu8RxNextByte)++;
    707              if( *psTargetUart_->pu8RxNextByte >= ( psTargetUart_->pu8RxBuffer + psTargetUart_->u16RxBufferSize ) )
    708              {
    709                *psTargetUart_->pu8RxNextByte = psTargetUart_->pu8RxBuffer; 
    710              }
    711              /* Always zero the current char in the buffer */
    712              **(psTargetUart_->pu8RxNextByte) = 0;
    713            }
    714                
    715          } /* end UartReadRxBuffer() */
    716          #endif
    717          
    718          /*----------------------------------------------------------------------------------------------------------------------
    719          Function: UartManualMode
    720          
    721          Description:
    722          Runs a transmit cycle of the UART application to clock out a message.  This function is used only during
    723          initialization.
    724          
    725          Requires:
    726            - UART application has been initialized.
    727          
    728          Promises:
    729            - All bytes currently in the UART Rx FIFO are read out to the application receive circular buffer.
    730          */

   \                                 In section .text, align 2, keep-with-next
    731          static void UartManualMode(void)
    732          {
   \                     UartManualMode: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    733            UART_u32Flags |=_UART_MANUAL_MODE;
   \   00000002   0x....             LDR.N    R0,??DataTable16_13
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0xF050 0x0001      ORRS     R0,R0,#0x1
   \   0000000A   0x....             LDR.N    R1,??DataTable16_13
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    734            UART_psCurrentUart = &UART_Peripheral;
   \   0000000E   0x....             LDR.N    R0,??DataTable16_3
   \   00000010   0x....             LDR.N    R1,??DataTable16_18
   \   00000012   0x6008             STR      R0,[R1, #+0]
    735            
    736            while(UART_u32Flags &_UART_MANUAL_MODE)
   \                     ??UartManualMode_0: (+1)
   \   00000014   0x....             LDR.N    R0,??DataTable16_13
   \   00000016   0x7800             LDRB     R0,[R0, #+0]
   \   00000018   0x07C0             LSLS     R0,R0,#+31
   \   0000001A   0xD50B             BPL.N    ??UartManualMode_1
    737            {
    738              Uart_pfnStateMachine();
   \   0000001C   0x....             LDR.N    R0,??DataTable16_11
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x4780             BLX      R0
    739              UART_u32Timer  = G_u32SystemTime1ms;
   \   00000022   0x....             LDR.N    R0,??DataTable16_19
   \   00000024   0x6800             LDR      R0,[R0, #+0]
   \   00000026   0x....             LDR.N    R1,??DataTable16_20
   \   00000028   0x6008             STR      R0,[R1, #+0]
    740              IsTimeUp(&UART_u32Timer, 1);
   \   0000002A   0x2101             MOVS     R1,#+1
   \   0000002C   0x....             LDR.N    R0,??DataTable16_20
   \   0000002E   0x.... 0x....      BL       IsTimeUp
   \   00000032   0xE7EF             B.N      ??UartManualMode_0
    741            }
    742                
    743          } /* end UartManualMode() */
   \                     ??UartManualMode_1: (+1)
   \   00000034   0xBD01             POP      {R0,PC}          ;; return
    744          
    745          
    746          #ifdef USE_SIMPLE_USART0
    747          /*----------------------------------------------------------------------------------------------------------------------
    748          Interrupt Service Routine: UART0_IRQHandler
    749          
    750          Description:
    751          Handles the enabled UART0 interrupts. 
    752          Receive: The UART peripheral is always enabled and ready to receive data.  Receive interrupts will occur when a
    753          new byte has been read by the peripheral. All incoming data is dumped into the circular receive data buffer UART_au8U0RxBuffer.
    754          No processing is done on the data - it is up to the processing application to parse incoming data to find useful information
    755          and to manage dummy bytes.
    756          
    757          Note that if the Rx buffer is not read and U0RX_BUFFER_SIZE characters come in, all data will be lost because of the popinter wrap.
    758          
    759          Transmit: All data bytes in the transmit buffer are immediately sent as fast as the interrupt can process them.
    760          
    761          Requires:
    762            - Only TXEMPTY and RXRDY interrupts are ever enabled
    763            - Transmit and receive buffers should be correctly configured 
    764          
    765          Promises:
    766            - If ENDRX interrupt occurs, the received character is deposited in UART_au8U0RxBuffer
    767            - If ENDTX interrupt occurs, the transmit buffer is checked to see if another character should be queued to the peripheral
    768          */
    769          
    770          void USART0_IrqHandler(void)
    771          {
    772            /* Check which interrupt has occurred */
    773            if(AT91C_BASE_US0->US_CSR & AT91C_US_RXRDY)
    774            {
    775              /* Move the received character into the buffer - clears the RXRDY flag */
    776              *UART_pu8U0RxBufferNextChar = (u8)(AT91C_BASE_US0->US_RHR);
    777              
    778              /* Safely advance the pointer */
    779              UART_pu8U0RxBufferNextChar++;
    780              if(UART_pu8U0RxBufferNextChar == &UART_au8U0RxBuffer[U0RX_BUFFER_SIZE])
    781              {
    782                UART_pu8U0RxBufferNextChar = &UART_au8U0RxBuffer[0];
    783              }
    784            }
    785          #if 0
    786            if(AT91C_BASE_US0->US_CSR & AT91C_US_TXEMPTY)
    787            {
    788              /* If the transmit buffer has more data to send, then queue the next byte */
    789              if(UART_pu8U0TxBufferUnsentChar != UART_pu8U0TxBufferNextChar)
    790              {
    791                /* Queue the next byte */
    792                AT91C_BASE_US0->US_THR = *UART_pu8U0TxBufferUnsentChar;
    793          
    794                /* Safely advance the pointer */
    795                UART_pu8U0TxBufferUnsentChar++;
    796                if(UART_pu8U0TxBufferUnsentChar == &UART_au8U0TxBuffer[U0TX_BUFFER_SIZE])
    797                {
    798                  UART_pu8U0TxBufferUnsentChar = &UART_au8U0TxBuffer[0];
    799                }
    800              }
    801              /* Otherwise all data has been sent */
    802              else
    803              {
    804                UART_u32Flags &= _UART_U0_SENDING;
    805                AT91C_BASE_US0->US_IER = AT91C_US_TXEMPTY;
    806              }
    807            }
    808          #endif
    809          } /* end UART0_IRQHandler() */
    810          #endif /* USE_SIMPLE_USART0 */
    811          
    812          
    813          /*----------------------------------------------------------------------------------------------------------------------
    814          Interrupt Service Routine: UART_IRQHandler
    815          
    816          Description:
    817          Handles the enabled UART interrupts for the current UART. 
    818          
    819          
    820          Requires:
    821            - No other interrupts UART interrupts may be active
    822          
    823          Promises:
    824            - Gets the current interrupt context and proceeds to the Generic handler
    825          */
    826          

   \                                 In section .text, align 2, keep-with-next
    827          void UART_IRQHandler(void)
    828          {
   \                     DBGU_IrqHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    829            /* Set the current ISR pointers to SSP1 targets */
    830            UART_psCurrentISR = &UART_Peripheral;                          /* Current UART ISR */
   \   00000002   0x....             LDR.N    R0,??DataTable16_3
   \   00000004   0x....             LDR.N    R1,??DataTable16_21
   \   00000006   0x6008             STR      R0,[R1, #+0]
    831            UART_pu32ApplicationFlagsISR = &G_u32UartApplicationFlags;     /* Current UART application status flags */
   \   00000008   0x....             LDR.N    R0,??DataTable16_22
   \   0000000A   0x....             LDR.N    R1,??DataTable16_23
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    832            UART_u32IntCount++;
   \   0000000E   0x....             LDR.N    R0,??DataTable16_24
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x1C40             ADDS     R0,R0,#+1
   \   00000014   0x....             LDR.N    R1,??DataTable16_24
   \   00000016   0x6008             STR      R0,[R1, #+0]
    833          
    834            /* Go to common SSP interrupt using psCurrentSspISR since the SSP cannot interrupt itself */
    835            UartGenericHandler();
   \   00000018   0x.... 0x....      BL       UartGenericHandler
    836          
    837          } /* end UART_IRQHandler() */
   \   0000001C   0xBD01             POP      {R0,PC}          ;; return
    838          
    839          
    840          /*----------------------------------------------------------------------------------------------------------------------
    841          Interrupt Service Routine: UART0_IRQHandler
    842          
    843          Description:
    844          Handles the enabled UART interrupts for the current UART. 
    845          
    846          
    847          Requires:
    848            - No other interrupts UART interrupts may be active
    849          
    850          Promises:
    851            - Gets the current interrupt context and proceeds to the Generic handler
    852          */
    853          

   \                                 In section .text, align 2, keep-with-next
    854          void UART0_IRQHandler(void)
    855          {
   \                     USART0_IrqHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    856            /* Set the current ISR pointers to SSP1 targets */
    857            UART_psCurrentISR = &UART_Peripheral0;                          /* Current UART ISR */
   \   00000002   0x....             LDR.N    R0,??DataTable16_5
   \   00000004   0x....             LDR.N    R1,??DataTable16_21
   \   00000006   0x6008             STR      R0,[R1, #+0]
    858            UART_pu32ApplicationFlagsISR = &G_u32Uart0ApplicationFlags;     /* Current UART application status flags */
   \   00000008   0x....             LDR.N    R0,??DataTable16_25
   \   0000000A   0x....             LDR.N    R1,??DataTable16_23
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    859            UART_u32Int0Count++;
   \   0000000E   0x....             LDR.N    R0,??DataTable16_26
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x1C40             ADDS     R0,R0,#+1
   \   00000014   0x....             LDR.N    R1,??DataTable16_26
   \   00000016   0x6008             STR      R0,[R1, #+0]
    860          
    861            /* Go to common interrupt */
    862            UartGenericHandler();
   \   00000018   0x.... 0x....      BL       UartGenericHandler
    863          
    864          } /* end UART0_IRQHandler() */
   \   0000001C   0xBD01             POP      {R0,PC}          ;; return
    865          
    866          
    867          /*----------------------------------------------------------------------------------------------------------------------
    868          Interrupt Service Routine: UART1_IRQHandler
    869          
    870          Description:
    871          Handles the enabled UART interrupts for the current UART. 
    872          
    873          
    874          Requires:
    875            - No other interrupts UART interrupts may be active
    876          
    877          Promises:
    878            - Gets the current interrupt context and proceeds to the Generic handler
    879          */
    880          

   \                                 In section .text, align 2, keep-with-next
    881          void UART1_IRQHandler(void)
    882          {
   \                     UART1_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    883            /* Set the current ISR pointers to SSP1 targets */
    884            UART_psCurrentISR = &UART_Peripheral1;                          /* Current UART ISR */
   \   00000002   0x....             LDR.N    R0,??DataTable16_6
   \   00000004   0x....             LDR.N    R1,??DataTable16_21
   \   00000006   0x6008             STR      R0,[R1, #+0]
    885            UART_pu32ApplicationFlagsISR = &G_u32Uart1ApplicationFlags;     /* Current UART application status flags */
   \   00000008   0x....             LDR.N    R0,??DataTable16_27
   \   0000000A   0x....             LDR.N    R1,??DataTable16_23
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    886            UART_u32Int1Count++;
   \   0000000E   0x....             LDR.N    R0,??DataTable16_28
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x1C40             ADDS     R0,R0,#+1
   \   00000014   0x....             LDR.N    R1,??DataTable16_28
   \   00000016   0x6008             STR      R0,[R1, #+0]
    887          
    888            /* Go to common interrupt */
    889            UartGenericHandler();
   \   00000018   0x.... 0x....      BL       UartGenericHandler
    890          
    891          } /* end UART1_IRQHandler() */
   \   0000001C   0xBD01             POP      {R0,PC}          ;; return
    892          
    893          
    894          /*----------------------------------------------------------------------------------------------------------------------
    895          Interrupt Service Routine: UART2_IRQHandler
    896          
    897          Description:
    898          Handles the enabled UART interrupts for the current UART. 
    899          
    900          
    901          Requires:
    902            - No other interrupts UART interrupts may be active
    903          
    904          Promises:
    905            - Gets the current interrupt context and proceeds to the Generic handler
    906          */
    907          

   \                                 In section .text, align 2, keep-with-next
    908          void UART2_IRQHandler(void)
    909          {
   \                     UART2_IRQHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    910            /* Set the current ISR pointers to SSP1 targets */
    911            UART_psCurrentISR = &UART_Peripheral2;                          /* Current UART ISR */
   \   00000002   0x....             LDR.N    R0,??DataTable16_8
   \   00000004   0x....             LDR.N    R1,??DataTable16_21
   \   00000006   0x6008             STR      R0,[R1, #+0]
    912            UART_pu32ApplicationFlagsISR = &G_u32Uart2ApplicationFlags;     /* Current UART application status flags */
   \   00000008   0x....             LDR.N    R0,??DataTable16_29
   \   0000000A   0x....             LDR.N    R1,??DataTable16_23
   \   0000000C   0x6008             STR      R0,[R1, #+0]
    913            UART_u32Int2Count++;
   \   0000000E   0x....             LDR.N    R0,??DataTable16_30
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x1C40             ADDS     R0,R0,#+1
   \   00000014   0x....             LDR.N    R1,??DataTable16_30
   \   00000016   0x6008             STR      R0,[R1, #+0]
    914          
    915            /* Go to common interrupt */
    916            UartGenericHandler();
   \   00000018   0x.... 0x....      BL       UartGenericHandler
    917          
    918          } /* end UART2_IRQHandler() */
   \   0000001C   0xBD01             POP      {R0,PC}          ;; return
    919          
    920          
    921          /*----------------------------------------------------------------------------------------------------------------------
    922          Generic Interrupt Service Routine
    923          
    924          Description:
    925          Receive: A requested UART peripheral is always enabled and ready to receive data.  Receive interrupts will occur when a
    926          new byte has been read by the peripheral. All incoming data is dumped into the circular receive data buffer configured.
    927          No processing is done on the data - it is up to the processing application to parse incoming data to find useful information
    928          and to manage dummy bytes.  All data reception is done with DMA, but only 1 byte at a time.  Receiving is done by using
    929          the two reception pointers to ensure no data is missed.
    930          
    931          Transmit: All data bytes in the transmit buffer are sent using DMA and interrupts. Once the full message has been sent,
    932          the message status is updated.
    933          */

   \                                 In section .text, align 2, keep-with-next
    934          void UartGenericHandler(void)
    935          {
   \                     UartGenericHandler: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    936            /* ENDRX Interrupt when a byte has been received (RNCR is moved to RCR; RNPR is copied to RPR))*/
    937            if( (UART_psCurrentISR->pBaseAddress->US_IMR & AT91C_US_ENDRX) && 
    938                (UART_psCurrentISR->pBaseAddress->US_CSR & AT91C_US_ENDRX) )
   \   00000002   0x....             LDR.N    R0,??DataTable16_21
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6800             LDR      R0,[R0, #+0]
   \   00000008   0x6900             LDR      R0,[R0, #+16]
   \   0000000A   0x0700             LSLS     R0,R0,#+28
   \   0000000C   0xD538             BPL.N    ??UartGenericHandler_0
   \   0000000E   0x....             LDR.N    R0,??DataTable16_21
   \   00000010   0x6800             LDR      R0,[R0, #+0]
   \   00000012   0x6800             LDR      R0,[R0, #+0]
   \   00000014   0x6940             LDR      R0,[R0, #+20]
   \   00000016   0x0700             LSLS     R0,R0,#+28
   \   00000018   0xD532             BPL.N    ??UartGenericHandler_0
    939            {
    940              /* Flag that a byte has arrived */
    941              *UART_pu32ApplicationFlagsISR |= _UART_RX_COMPLETE;
   \   0000001A   0x....             LDR.N    R0,??DataTable16_23
   \   0000001C   0x6800             LDR      R0,[R0, #+0]
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000024   0x....             LDR.N    R1,??DataTable16_23
   \   00000026   0x6809             LDR      R1,[R1, #+0]
   \   00000028   0x6008             STR      R0,[R1, #+0]
    942          
    943              /* Update the "next" DMA pointer to the next valid Rx location */
    944              UART_psCurrentISR->pBaseAddress->US_RNPR++;
   \   0000002A   0x....             LDR.N    R0,??DataTable16_21
   \   0000002C   0x6800             LDR      R0,[R0, #+0]
   \   0000002E   0x6800             LDR      R0,[R0, #+0]
   \   00000030   0xF8D0 0x0110      LDR      R0,[R0, #+272]
   \   00000034   0x1C40             ADDS     R0,R0,#+1
   \   00000036   0x....             LDR.N    R1,??DataTable16_21
   \   00000038   0x6809             LDR      R1,[R1, #+0]
   \   0000003A   0x6809             LDR      R1,[R1, #+0]
   \   0000003C   0xF8C1 0x0110      STR      R0,[R1, #+272]
    945              if(UART_psCurrentISR->pBaseAddress->US_RNPR == (u32)(UART_psCurrentISR->pu8RxBuffer + (u32)UART_psCurrentISR->u16RxBufferSize) )
   \   00000040   0x....             LDR.N    R0,??DataTable16_21
   \   00000042   0x6800             LDR      R0,[R0, #+0]
   \   00000044   0x6800             LDR      R0,[R0, #+0]
   \   00000046   0xF8D0 0x0110      LDR      R0,[R0, #+272]
   \   0000004A   0x....             LDR.N    R1,??DataTable16_21
   \   0000004C   0x6809             LDR      R1,[R1, #+0]
   \   0000004E   0x6949             LDR      R1,[R1, #+20]
   \   00000050   0x....             LDR.N    R2,??DataTable16_21
   \   00000052   0x6812             LDR      R2,[R2, #+0]
   \   00000054   0x8C12             LDRH     R2,[R2, #+32]
   \   00000056   0x1851             ADDS     R1,R2,R1
   \   00000058   0x4288             CMP      R0,R1
   \   0000005A   0xD107             BNE.N    ??UartGenericHandler_1
    946              {
    947                UART_psCurrentISR->pBaseAddress->US_RNPR = (u32)UART_psCurrentISR->pu8RxBuffer;  /* !!!!! CHECK */
   \   0000005C   0x....             LDR.N    R0,??DataTable16_21
   \   0000005E   0x6800             LDR      R0,[R0, #+0]
   \   00000060   0x6940             LDR      R0,[R0, #+20]
   \   00000062   0x....             LDR.N    R1,??DataTable16_21
   \   00000064   0x6809             LDR      R1,[R1, #+0]
   \   00000066   0x6809             LDR      R1,[R1, #+0]
   \   00000068   0xF8C1 0x0110      STR      R0,[R1, #+272]
    948              }
    949          
    950              /* Invoke the callback */
    951              UART_psCurrentISR->fnRxCallback();
   \                     ??UartGenericHandler_1: (+1)
   \   0000006C   0x....             LDR.N    R0,??DataTable16_21
   \   0000006E   0x6800             LDR      R0,[R0, #+0]
   \   00000070   0x69C0             LDR      R0,[R0, #+28]
   \   00000072   0x4780             BLX      R0
    952              
    953              /* Write RNCR to 1 to clear the ENDRX flag */
    954              UART_psCurrentISR->pBaseAddress->US_RNCR = 1;
   \   00000074   0x2001             MOVS     R0,#+1
   \   00000076   0x....             LDR.N    R1,??DataTable16_21
   \   00000078   0x6809             LDR      R1,[R1, #+0]
   \   0000007A   0x6809             LDR      R1,[R1, #+0]
   \   0000007C   0xF8C1 0x0114      STR      R0,[R1, #+276]
    955            }
    956          
    957            
    958            /* ENDTX Interrupt when all requested transmit bytes have been sent (if enabled) */
    959            if( (UART_psCurrentISR->pBaseAddress->US_IMR & AT91C_US_ENDTX) && 
    960                (UART_psCurrentISR->pBaseAddress->US_CSR & AT91C_US_ENDTX) )
   \                     ??UartGenericHandler_0: (+1)
   \   00000080   0x....             LDR.N    R0,??DataTable16_21
   \   00000082   0x6800             LDR      R0,[R0, #+0]
   \   00000084   0x6800             LDR      R0,[R0, #+0]
   \   00000086   0x6900             LDR      R0,[R0, #+16]
   \   00000088   0x06C0             LSLS     R0,R0,#+27
   \   0000008A   0xD532             BPL.N    ??UartGenericHandler_2
   \   0000008C   0x....             LDR.N    R0,??DataTable16_21
   \   0000008E   0x6800             LDR      R0,[R0, #+0]
   \   00000090   0x6800             LDR      R0,[R0, #+0]
   \   00000092   0x6940             LDR      R0,[R0, #+20]
   \   00000094   0x06C0             LSLS     R0,R0,#+27
   \   00000096   0xD52C             BPL.N    ??UartGenericHandler_2
    961            {
    962              /* Update this message token status and then DeQueue it */
    963              UpdateMessageStatus(UART_psCurrentISR->psTransmitBuffer->u32Token, COMPLETE);
   \   00000098   0x2104             MOVS     R1,#+4
   \   0000009A   0x....             LDR.N    R0,??DataTable16_21
   \   0000009C   0x6800             LDR      R0,[R0, #+0]
   \   0000009E   0x6880             LDR      R0,[R0, #+8]
   \   000000A0   0x6800             LDR      R0,[R0, #+0]
   \   000000A2   0x.... 0x....      BL       UpdateMessageStatus
    964              DeQueueMessage( &UART_psCurrentISR->psTransmitBuffer );
   \   000000A6   0x....             LDR.N    R0,??DataTable16_21
   \   000000A8   0x6800             LDR      R0,[R0, #+0]
   \   000000AA   0x3008             ADDS     R0,R0,#+8
   \   000000AC   0x.... 0x....      BL       DeQueueMessage
    965              UART_psCurrentISR->u32PrivateFlags &= ~_UART_PERIPHERAL_TX;
   \   000000B0   0x....             LDR.N    R0,??DataTable16_21
   \   000000B2   0x6800             LDR      R0,[R0, #+0]
   \   000000B4   0x6840             LDR      R0,[R0, #+4]
   \   000000B6   0xF430 0x1000      BICS     R0,R0,#0x200000
   \   000000BA   0x....             LDR.N    R1,??DataTable16_21
   \   000000BC   0x6809             LDR      R1,[R1, #+0]
   \   000000BE   0x6048             STR      R0,[R1, #+4]
    966                  
    967              /* Disable the transmitter and interrupt source */
    968              UART_psCurrentISR->pBaseAddress->US_PTCR = AT91C_PDC_TXTDIS;
   \   000000C0   0xF44F 0x7000      MOV      R0,#+512
   \   000000C4   0x....             LDR.N    R1,??DataTable16_21
   \   000000C6   0x6809             LDR      R1,[R1, #+0]
   \   000000C8   0x6809             LDR      R1,[R1, #+0]
   \   000000CA   0xF8C1 0x0120      STR      R0,[R1, #+288]
    969              UART_psCurrentISR->pBaseAddress->US_IDR  = AT91C_US_ENDTX;
   \   000000CE   0x2010             MOVS     R0,#+16
   \   000000D0   0x....             LDR.N    R1,??DataTable16_21
   \   000000D2   0x6809             LDR      R1,[R1, #+0]
   \   000000D4   0x6809             LDR      R1,[R1, #+0]
   \   000000D6   0x60C8             STR      R0,[R1, #+12]
    970              
    971              /* Decrement # of active UARTs */
    972              if(UART_u8ActiveUarts != 0)
   \   000000D8   0x....             LDR.N    R0,??DataTable16_31
   \   000000DA   0x7800             LDRB     R0,[R0, #+0]
   \   000000DC   0x2800             CMP      R0,#+0
   \   000000DE   0xD005             BEQ.N    ??UartGenericHandler_3
    973              {
    974                UART_u8ActiveUarts--;
   \   000000E0   0x....             LDR.N    R0,??DataTable16_31
   \   000000E2   0x7800             LDRB     R0,[R0, #+0]
   \   000000E4   0x1E40             SUBS     R0,R0,#+1
   \   000000E6   0x....             LDR.N    R1,??DataTable16_31
   \   000000E8   0x7008             STRB     R0,[R1, #+0]
   \   000000EA   0xE002             B.N      ??UartGenericHandler_2
    975              }
    976              else
    977              {
    978                /* If UART_u8ActiveUarts is already 0, then we are not properly synchronized */
    979                DebugPrintf("\n\rUART counter out of sync\n\r");
   \                     ??UartGenericHandler_3: (+1)
   \   000000EC   0x....             LDR.N    R0,??DataTable16_32
   \   000000EE   0x.... 0x....      BL       DebugPrintf
    980              }
    981            }
    982            
    983          } /* end SspGenericHandler() */
   \                     ??UartGenericHandler_2: (+1)
   \   000000F2   0xBD01             POP      {R0,PC}          ;; return
    984          
    985          
    986          /***********************************************************************************************************************
    987          State Machine Function Definitions
    988          
    989          The UART state machine monitors messaging activity on the available UART peripherals.  It manages outgoing messages and will
    990          transmit any bytes that has been queued.  Only one message will be transferred at once (e.g. UART1 and UART2 will not both 
    991          send at the same time, though both peripherals will continue to receive simultaneously).
    992          Since all transmit and receive bytes are transferred using interrupts, the SM does not have to worry about prioritizing.
    993          
    994          Transmitting on USART 0:
    995          When UART_pu8U0TxBufferUnsentChar doesn't match UART_pu8U0TxBufferNextChar, then we know that there is data to send.
    996          Data transfer is initiated by writing the first byte and setting the _UART_U0_SENDING flag to keep the USART state machine 
    997          busy sending all of the current data on the USART.  The interrupt service routine will be responsible for clearing the
    998          bit which will allow the SM to return to Idle.  
    999          
   1000          Receiving on USART 0:
   1001          Since the UART can only talk to one device, we will hard-code some of the functionality.  Reception of bytes will
   1002          simply dump into the UartRxBuffer and the task interested in those bytes can read the data.  In this case, we
   1003          know that this is only the Debug / User interface task.  Though other tasks could also access the buffer, we
   1004          assume they won't.
   1005          
   1006          ***********************************************************************************************************************/
   1007          
   1008          /*-------------------------------------------------------------------------------------------------------------------*/
   1009          /* Wait for a transmit message to be queued.  Received data is handled in interrupts. */

   \                                 In section .text, align 4, keep-with-next
   1010          void UartSM_Idle(void)
   1011          {
   \                     UartSM_Idle: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
   1012          #if USE_SIMPLE_USART0
   1013            u8 u8Temp;
   1014          
   1015            /* Send on the debug UART */
   1016            if( (UART_pu8U0TxBufferUnsentChar != UART_pu8U0TxBufferNextChar) && !(UART_u32Flags & _UART_U0_SENDING) )
   1017            {
   1018              /* Flag that a send on U0 is in progress */
   1019              UART_u32Flags |= _UART_U0_SENDING;
   1020              
   1021              /* Get a copy of the next byte and safely advance the pointer */
   1022              u8Temp = *UART_pu8U0TxBufferUnsentChar;
   1023              UART_pu8U0TxBufferUnsentChar++;
   1024              if(UART_pu8U0TxBufferUnsentChar == &UART_au8U0TxBuffer[U0TX_BUFFER_SIZE])
   1025              {
   1026                UART_pu8U0TxBufferUnsentChar = &UART_au8U0TxBuffer[0];
   1027              }
   1028              
   1029              /* Queue the next byte and enable the Tx interrupt */
   1030              AT91C_BASE_US0->US_THR = u8Temp;
   1031              AT91C_BASE_US0->US_IER = AT91C_US_TXEMPTY;
   1032            }
   1033          #endif /* USE_SIMPLE_USART0 */
   1034          
   1035            /* Check all UART peripherals for message activity or skip the current peripheral if it is already busy sending.
   1036            All receive functions take place outside of the state machine.
   1037            Devices sending a message will have UART_psCurrentSsp->psTransmitBuffer->pu8Message pointing to the message to send. */
   1038            if( (UART_psCurrentUart->psTransmitBuffer != NULL) && 
   1039               !(UART_psCurrentUart->u32PrivateFlags & _UART_PERIPHERAL_TX ) )
   \   00000002   0x....             LDR.N    R0,??DataTable16_18
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x6880             LDR      R0,[R0, #+8]
   \   00000008   0x2800             CMP      R0,#+0
   \   0000000A   0xD036             BEQ.N    ??UartSM_Idle_0
   \   0000000C   0x....             LDR.N    R0,??DataTable16_18
   \   0000000E   0x6800             LDR      R0,[R0, #+0]
   \   00000010   0x6840             LDR      R0,[R0, #+4]
   \   00000012   0x0280             LSLS     R0,R0,#+10
   \   00000014   0xD431             BMI.N    ??UartSM_Idle_0
   1040            {
   1041              /* Transmitting: update the message's status and flag that the peripheral is now busy */
   1042              UpdateMessageStatus(UART_psCurrentUart->psTransmitBuffer->u32Token, SENDING);
   \   00000016   0x2102             MOVS     R1,#+2
   \   00000018   0x....             LDR.N    R0,??DataTable16_18
   \   0000001A   0x6800             LDR      R0,[R0, #+0]
   \   0000001C   0x6880             LDR      R0,[R0, #+8]
   \   0000001E   0x6800             LDR      R0,[R0, #+0]
   \   00000020   0x.... 0x....      BL       UpdateMessageStatus
   1043              UART_psCurrentUart->u32PrivateFlags |= _UART_PERIPHERAL_TX;    
   \   00000024   0x....             LDR.N    R0,??DataTable16_18
   \   00000026   0x6800             LDR      R0,[R0, #+0]
   \   00000028   0x6840             LDR      R0,[R0, #+4]
   \   0000002A   0xF450 0x1000      ORRS     R0,R0,#0x200000
   \   0000002E   0x....             LDR.N    R1,??DataTable16_18
   \   00000030   0x6809             LDR      R1,[R1, #+0]
   \   00000032   0x6048             STR      R0,[R1, #+4]
   1044                
   1045              /* Load the PDC counter and pointer registers */
   1046              UART_psCurrentUart->pBaseAddress->US_TPR = (unsigned int)UART_psCurrentUart->psTransmitBuffer->pu8Message; /* CHECK */
   \   00000034   0x....             LDR.N    R0,??DataTable16_18
   \   00000036   0x6800             LDR      R0,[R0, #+0]
   \   00000038   0x6880             LDR      R0,[R0, #+8]
   \   0000003A   0x3008             ADDS     R0,R0,#+8
   \   0000003C   0x....             LDR.N    R1,??DataTable16_18
   \   0000003E   0x6809             LDR      R1,[R1, #+0]
   \   00000040   0x6809             LDR      R1,[R1, #+0]
   \   00000042   0xF8C1 0x0108      STR      R0,[R1, #+264]
   1047              UART_psCurrentUart->pBaseAddress->US_TCR = UART_psCurrentUart->psTransmitBuffer->u32Size;
   \   00000046   0x....             LDR.N    R0,??DataTable16_18
   \   00000048   0x6800             LDR      R0,[R0, #+0]
   \   0000004A   0x6880             LDR      R0,[R0, #+8]
   \   0000004C   0x6840             LDR      R0,[R0, #+4]
   \   0000004E   0x....             LDR.N    R1,??DataTable16_18
   \   00000050   0x6809             LDR      R1,[R1, #+0]
   \   00000052   0x6809             LDR      R1,[R1, #+0]
   \   00000054   0xF8C1 0x010C      STR      R0,[R1, #+268]
   1048          
   1049              /* When TCR is loaded, the ENDTX flag is cleared so it is safe to enable the interrupt */
   1050              UART_psCurrentUart->pBaseAddress->US_IER = AT91C_US_ENDTX;
   \   00000058   0x2010             MOVS     R0,#+16
   \   0000005A   0x....             LDR.N    R1,??DataTable16_18
   \   0000005C   0x6809             LDR      R1,[R1, #+0]
   \   0000005E   0x6809             LDR      R1,[R1, #+0]
   \   00000060   0x6088             STR      R0,[R1, #+8]
   1051              
   1052              /* Update active UART count and enable the transmitter to start the transfer */
   1053              UART_u8ActiveUarts++;
   \   00000062   0x....             LDR.N    R0,??DataTable16_31
   \   00000064   0x7800             LDRB     R0,[R0, #+0]
   \   00000066   0x1C40             ADDS     R0,R0,#+1
   \   00000068   0x....             LDR.N    R1,??DataTable16_31
   \   0000006A   0x7008             STRB     R0,[R1, #+0]
   1054              UART_psCurrentUart->pBaseAddress->US_PTCR = AT91C_PDC_TXTEN;
   \   0000006C   0xF44F 0x7080      MOV      R0,#+256
   \   00000070   0x....             LDR.N    R1,??DataTable16_18
   \   00000072   0x6809             LDR      R1,[R1, #+0]
   \   00000074   0x6809             LDR      R1,[R1, #+0]
   \   00000076   0xF8C1 0x0120      STR      R0,[R1, #+288]
   1055            }
   1056            
   1057            /* Adjust to check the next peripheral next time through */
   1058            switch (UART_psCurrentUart->u8PeripheralId)
   \                     ??UartSM_Idle_0: (+1)
   \   0000007A   0x....             LDR.N    R0,??DataTable16_18
   \   0000007C   0x6800             LDR      R0,[R0, #+0]
   \   0000007E   0xF890 0x0022      LDRB     R0,[R0, #+34]
   \   00000082   0x2808             CMP      R0,#+8
   \   00000084   0xD006             BEQ.N    ??UartSM_Idle_1
   \   00000086   0x280D             CMP      R0,#+13
   \   00000088   0xD008             BEQ.N    ??UartSM_Idle_2
   \   0000008A   0x280E             CMP      R0,#+14
   \   0000008C   0xD00A             BEQ.N    ??UartSM_Idle_3
   \   0000008E   0x280F             CMP      R0,#+15
   \   00000090   0xD00C             BEQ.N    ??UartSM_Idle_4
   \   00000092   0xE01D             B.N      ??UartSM_Idle_5
   1059            {
   1060              case AT91C_ID_DBGU:
   1061                UART_psCurrentUart = &UART_Peripheral0;
   \                     ??UartSM_Idle_1: (+1)
   \   00000094   0x....             LDR.N    R0,??DataTable16_5
   \   00000096   0x....             LDR.N    R1,??DataTable16_18
   \   00000098   0x6008             STR      R0,[R1, #+0]
   1062                break;
   \   0000009A   0xE01C             B.N      ??UartSM_Idle_6
   1063          
   1064              case AT91C_ID_US0:
   1065                UART_psCurrentUart = &UART_Peripheral1;
   \                     ??UartSM_Idle_2: (+1)
   \   0000009C   0x....             LDR.N    R0,??DataTable16_6
   \   0000009E   0x....             LDR.N    R1,??DataTable16_18
   \   000000A0   0x6008             STR      R0,[R1, #+0]
   1066                break;
   \   000000A2   0xE018             B.N      ??UartSM_Idle_6
   1067          
   1068              case AT91C_ID_US1:
   1069                UART_psCurrentUart = &UART_Peripheral2;
   \                     ??UartSM_Idle_3: (+1)
   \   000000A4   0x....             LDR.N    R0,??DataTable16_8
   \   000000A6   0x....             LDR.N    R1,??DataTable16_18
   \   000000A8   0x6008             STR      R0,[R1, #+0]
   1070                break;
   \   000000AA   0xE014             B.N      ??UartSM_Idle_6
   1071          
   1072              case AT91C_ID_US2:
   1073                UART_psCurrentUart = &UART_Peripheral;
   \                     ??UartSM_Idle_4: (+1)
   \   000000AC   0x....             LDR.N    R0,??DataTable16_3
   \   000000AE   0x....             LDR.N    R1,??DataTable16_18
   \   000000B0   0x6008             STR      R0,[R1, #+0]
   1074                
   1075                /* Only clear _UART_MANUAL_MODE if all UARTs are done sending to ensure messages are sent during initialization */
   1076                if( (G_u32SystemFlags & _SYSTEM_INITIALIZING) && !UART_u8ActiveUarts)
   \   000000B2   0x....             LDR.N    R0,??DataTable16_12
   \   000000B4   0x6800             LDR      R0,[R0, #+0]
   \   000000B6   0x2800             CMP      R0,#+0
   \   000000B8   0xD509             BPL.N    ??UartSM_Idle_7
   \   000000BA   0x....             LDR.N    R0,??DataTable16_31
   \   000000BC   0x7800             LDRB     R0,[R0, #+0]
   \   000000BE   0x2800             CMP      R0,#+0
   \   000000C0   0xD105             BNE.N    ??UartSM_Idle_7
   1077                {
   1078                  UART_u32Flags &= ~_UART_MANUAL_MODE;
   \   000000C2   0x....             LDR.N    R0,??DataTable16_13
   \   000000C4   0x6800             LDR      R0,[R0, #+0]
   \   000000C6   0x0840             LSRS     R0,R0,#+1
   \   000000C8   0x0040             LSLS     R0,R0,#+1
   \   000000CA   0x....             LDR.N    R1,??DataTable16_13
   \   000000CC   0x6008             STR      R0,[R1, #+0]
   1079                }
   1080                break;
   \                     ??UartSM_Idle_7: (+1)
   \   000000CE   0xE002             B.N      ??UartSM_Idle_6
   1081          
   1082              default:
   1083                UART_psCurrentUart = &UART_Peripheral;
   \                     ??UartSM_Idle_5: (+1)
   \   000000D0   0x....             LDR.N    R0,??DataTable16_3
   \   000000D2   0x....             LDR.N    R1,??DataTable16_18
   \   000000D4   0x6008             STR      R0,[R1, #+0]
   1084                break;
   1085            } /* end switch */
   1086            
   1087          } /* end UartSM_Idle() */
   \                     ??UartSM_Idle_6: (+1)
   \   000000D6   0xBD01             POP      {R0,PC}          ;; return
   1088          
   1089          
   1090          #ifdef USE_SIMPLE_USART0        
   1091          /*-------------------------------------------------------------------------------------------------------------------*/
   1092          /* Transmit in progress until current bytes have reached 0.  On exit, the transmit message must be dequeued.
   1093          */
   1094          void UartSM_Transmitting(void)
   1095          {
   1096            /* Check if all of the message bytes have completely finished sending */
   1097            if( (UART_u32CurrentTxBytesRemaining == 0) && 
   1098                (UART_psCurrentUart->pBaseAddress->US_IER & AT91C_US_TXEMPTY) )
   1099            {
   1100              /* Update the status queue and then dequeue the message */
   1101              UpdateMessageStatus(UART_psCurrentUart->pTransmitBuffer->u32Token, COMPLETE);
   1102              DeQueueMessage(&UART_psCurrentUart->pTransmitBuffer);
   1103          
   1104              /* Make sure _UART_INIT_MODE flag is clear in case this was a manual cycle */
   1105              UART_u32Flags &= ~_UART_INIT_MODE;
   1106              Uart_pfnStateMachine = UartSM_Idle;
   1107            }
   1108              
   1109          } /* end UartSM_Transmitting() */
   1110          #endif /* USE_SIMPLE_USART0 */
   1111          
   1112          /*-------------------------------------------------------------------------------------------------------------------*/
   1113          /* Handle an error */

   \                                 In section .text, align 2, keep-with-next
   1114          void UartSM_Error(void)          
   1115          {
   1116            UART_u32Flags &= ~UART_ERROR_FLAG_MASK;
   \                     UartSM_Error: (+1)
   \   00000000   0x....             LDR.N    R0,??DataTable16_13
   \   00000002   0x6800             LDR      R0,[R0, #+0]
   \   00000004   0x0200             LSLS     R0,R0,#+8        ;; ZeroExtS R0,R0,#+8,#+8
   \   00000006   0x0A00             LSRS     R0,R0,#+8
   \   00000008   0x....             LDR.N    R1,??DataTable16_13
   \   0000000A   0x6008             STR      R0,[R1, #+0]
   1117            
   1118            Uart_pfnStateMachine = UartSM_Idle;
   \   0000000C   0x....             LDR.N    R0,??DataTable16_33
   \   0000000E   0x....             LDR.N    R1,??DataTable16_11
   \   00000010   0x6008             STR      R0,[R1, #+0]
   1119            
   1120          } /* end UartSM_Error() */
   \   00000012   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_1:
   \   00000000   0xE000E180         DC32     0xe000e180

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_2:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_3:
   \   00000000   0x........         DC32     UART_Peripheral

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_4:
   \   00000000   0x004008C0         DC32     0x4008c0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_5:
   \   00000000   0x........         DC32     UART_Peripheral0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_6:
   \   00000000   0x........         DC32     UART_Peripheral1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_7:
   \   00000000   0x004518CE         DC32     0x4518ce

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_8:
   \   00000000   0x........         DC32     UART_Peripheral2

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_9:
   \   00000000   0x004118FF         DC32     0x4118ff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_10:
   \   00000000   0x400E0410         DC32     0x400e0410

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_11:
   \   00000000   0x........         DC32     Uart_pfnStateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_12:
   \   00000000   0x........         DC32     G_u32SystemFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_13:
   \   00000000   0x........         DC32     UART_u32Flags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_14:
   \   00000000   0x400E0600         DC32     0x400e0600

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_15:
   \   00000000   0x40090000         DC32     0x40090000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_16:
   \   00000000   0x40094000         DC32     0x40094000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_17:
   \   00000000   0x40098000         DC32     0x40098000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_18:
   \   00000000   0x........         DC32     UART_psCurrentUart

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_19:
   \   00000000   0x........         DC32     G_u32SystemTime1ms

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_20:
   \   00000000   0x........         DC32     UART_u32Timer

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_21:
   \   00000000   0x........         DC32     UART_psCurrentISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_22:
   \   00000000   0x........         DC32     G_u32UartApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_23:
   \   00000000   0x........         DC32     UART_pu32ApplicationFlagsISR

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_24:
   \   00000000   0x........         DC32     UART_u32IntCount

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_25:
   \   00000000   0x........         DC32     G_u32Uart0ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_26:
   \   00000000   0x........         DC32     UART_u32Int0Count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_27:
   \   00000000   0x........         DC32     G_u32Uart1ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_28:
   \   00000000   0x........         DC32     UART_u32Int1Count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_29:
   \   00000000   0x........         DC32     G_u32Uart2ApplicationFlags

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_30:
   \   00000000   0x........         DC32     UART_u32Int2Count

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_31:
   \   00000000   0x........         DC32     UART_u8ActiveUarts

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_32:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable16_33:
   \   00000000   0x........         DC32     UartSM_Idle

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x0A 0x0D          DC8 "\012\015UART counter out of sync\012\015"
   \              0x55 0x41    
   \              0x52 0x54    
   \              0x20 0x63    
   \              0x6F 0x75    
   \              0x6E 0x74    
   \              0x65 0x72    
   \              0x20 0x6F    
   \              0x75 0x74    
   \              0x20 0x6F    
   \              0x66 0x20    
   \              0x73 0x79    
   \              0x6E 0x63    
   \              0x0A 0x0D    
   \              0x00         
   \   0000001D   0x00 0x00          DC8 0, 0, 0
   \              0x00         
   1121          
   1122                    
   1123                    
   1124                    
   1125                    
   1126                  
   1127          /*--------------------------------------------------------------------------------------------------------------------*/
   1128          /* End of File */
   1129          /*--------------------------------------------------------------------------------------------------------------------*/
   1130          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   DBGU_IrqHandler
         8   -> UartGenericHandler
       0   NVIC_ClearPendingIRQ
       0   NVIC_DisableIRQ
       0   NVIC_EnableIRQ
       8   UART1_IRQHandler
         8   -> UartGenericHandler
       8   UART2_IRQHandler
         8   -> UartGenericHandler
       8   USART0_IrqHandler
         8   -> UartGenericHandler
       8   UartGenericHandler
         8   -- Indirect call
         8   -> DeQueueMessage
         8   -> DebugPrintf
         8   -> UpdateMessageStatus
       0   UartInitialize
       8   UartManualMode
         8   -- Indirect call
         8   -> IsTimeUp
       8   UartRelease
         8   -> DeQueueMessage
         8   -> NVIC_ClearPendingIRQ
         8   -> NVIC_DisableIRQ
         8   -> UpdateMessageStatus
      32   UartRequest
        32   -> NVIC_ClearPendingIRQ
        32   -> NVIC_EnableIRQ
       8   UartRunActiveState
         8   -- Indirect call
       0   UartSM_Error
       8   UartSM_Idle
         8   -> UpdateMessageStatus
      24   UartWriteByte
        24   -> QueueMessage
        24   -> UartManualMode
      24   UartWriteData
        24   -> QueueMessage
        24   -> UartManualMode


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_10
       4  ??DataTable16_11
       4  ??DataTable16_12
       4  ??DataTable16_13
       4  ??DataTable16_14
       4  ??DataTable16_15
       4  ??DataTable16_16
       4  ??DataTable16_17
       4  ??DataTable16_18
       4  ??DataTable16_19
       4  ??DataTable16_2
       4  ??DataTable16_20
       4  ??DataTable16_21
       4  ??DataTable16_22
       4  ??DataTable16_23
       4  ??DataTable16_24
       4  ??DataTable16_25
       4  ??DataTable16_26
       4  ??DataTable16_27
       4  ??DataTable16_28
       4  ??DataTable16_29
       4  ??DataTable16_3
       4  ??DataTable16_30
       4  ??DataTable16_31
       4  ??DataTable16_32
       4  ??DataTable16_33
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable16_8
       4  ??DataTable16_9
      32  ?_0
      30  DBGU_IrqHandler
       4  G_u32Uart0ApplicationFlags
       4  G_u32Uart1ApplicationFlags
       4  G_u32Uart2ApplicationFlags
       4  G_u32UartApplicationFlags
      22  NVIC_ClearPendingIRQ
      22  NVIC_DisableIRQ
      22  NVIC_EnableIRQ
      30  UART1_IRQHandler
      30  UART2_IRQHandler
      36  UART_Peripheral
      36  UART_Peripheral0
      36  UART_Peripheral1
      36  UART_Peripheral2
       4  UART_psCurrentISR
       4  UART_psCurrentUart
       4  UART_pu32ApplicationFlagsISR
       4  UART_u32Flags
       4  UART_u32Int0Count
       4  UART_u32Int1Count
       4  UART_u32Int2Count
       4  UART_u32IntCount
       4  UART_u32Timer
       1  UART_u8ActiveUarts
      30  USART0_IrqHandler
     244  UartGenericHandler
     252  UartInitialize
      54  UartManualMode
      84  UartRelease
     312  UartRequest
      10  UartRunActiveState
      20  UartSM_Error
     216  UartSM_Idle
      48  UartWriteByte
      44  UartWriteData
       4  Uart_pfnStateMachine

 
   201 bytes in section .bss
    32 bytes in section .rodata
 1 606 bytes in section .text
 
 1 606 bytes of CODE  memory
    32 bytes of CONST memory
   201 bytes of DATA  memory

Errors: none
Warnings: none
