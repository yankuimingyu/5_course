###############################################################################
#
# IAR ANSI C/C++ Compiler V7.20.2.7424/W32 for ARM        06/May/2017  16:08:23
# Copyright 1999-2014 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpg_common\drivers\adc12.c
#    Command line =  
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpg_common\drivers\adc12.c
#        -D MPGL1 -D MPG1 -D EIE1 --preprocess=cl
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\Debug\List\
#        -lC
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\Debug\List\
#        -o
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\Debug\Obj\
#        --no_cse --no_unroll --no_inline --no_code_motion --no_tbaa
#        --no_clustering --no_scheduling --debug --endian=little
#        --cpu=Cortex-M3 -e --fpu=None --dlib_config "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench
#        7.0\arm\INC\c\DLib_Config_Normal.h" -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\ -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\..\bsp\
#        -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\..\drivers\
#        -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\..\application\
#        -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\
#        -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\application\
#        -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\cmsis\
#        -I
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\..\..\firmware_mpg_common\drivers\
#        -On --use_c++_inline --require_prototypes -I "D:\Program Files
#        (x86)\IAR Systems\Embedded Workbench 7.0\arm\CMSIS\Include\"
#    List file    =  
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\Debug\List\adc12.lst
#    Object file  =  
#        D:\Documents\GitHub\5-5eie\5_course\firmware_mpgl1\iar_7_20_1\Debug\Obj\adc12.o
#
###############################################################################

D:\Documents\GitHub\5-5eie\5_course\firmware_mpg_common\drivers\adc12.c
      1          /**********************************************************************************************************************
      2          File: adc12.c                                                                
      3          
      4          Description:
      5          Driver function to give access to the 12-bit ADC on the EiE development boards.  
      6          The ADC hardware is the same for the EiE 1 and EiE 2 development board Blade connectors.
      7          The EiE1 board has an additional on-board potentiometer for testing purporses.
      8          
      9          This driver currently only provides setup and single result read access from any
     10          channel on the ADC at a time.  Any averaging or special operations should be handled by the
     11          application using the driver.  This driver is set up as a state machine for future
     12          feature additions.
     13          
     14          The first sample tends to read 20-30 bits high.  If no sample is taken for a few minutes,
     15          the next first sample will also read high.  This implies a long time constant in the hold
     16          time, but the timing parameters that have been set all line up with the electrical
     17          characteristics and source impedence considerations.  So this is a mystery for
     18          now -- suggest the first sample is thrown out, or average it out with at least 16 samples
     19          per displayed result which will reduce the error down to 1 or 2 LSBs.  
     20          
     21          ------------------------------------------------------------------------------------------------------------------------
     22          API:
     23          
     24          TYPES
     25          Adc12ChannelType {ADC12_CH0...ADC12_CH7}
     26          
     27          PUBLIC FUNCTIONS
     28          void Adc12AssignCallback(Adc12ChannelType eAdcChannel_, fnCode_u16_type fpUserCallback_)
     29          Assigns callback for the client application.  This is how the ADC result for any channel
     30          is accessed.  The callback function must have one u16 parameter where the result is passed.
     31          Different callbacks may be assigned for each channel. 
     32          
     33          e.g. to read AN0 from the blade connector (which is channel 2 on the ADC):
     34          void UserApp_AdcCallback(u16 u16Result_);
     35          ...
     36          Adc12AssignCallback(ADC12_CH2, UserApp_AdcCallback);
     37          
     38          
     39          bool Adc12StartConversion(Adc12ChannelType eAdcChannel_)
     40          Checks if the ADC is available and starts the conversion on the selected channel.
     41          Returns TRUE if the conversion is started; returns FALSE if the ADC is not available.
     42          e.g.
     43          bool bConversionStarted = FALSE;
     44          bConversionStarted = Adc12StartConversion(ADC12_CH2);
     45          
     46          
     47          PROTECTED FUNCTIONS
     48          void Adc12Initialize(void)
     49          Runs required initialzation for the task.  Should only be called once in main init section.
     50          
     51          void Adc12RunActiveState(void)
     52          Runs current task state.  Should only be called once in main loop.
     53          
     54          
     55          **********************************************************************************************************************/
     56          
     57          #include "configuration.h"

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_EnableIRQ(IRQn_Type)
   \                     NVIC_EnableIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x....             LDR.N    R2,??DataTable6  ;; 0xe000e100
   \   0000000A   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000C   0x0943             LSRS     R3,R0,#+5
   \   0000000E   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000012   0x4770             BX       LR               ;; return

   \                                 In section .text, align 2, keep-with-next
   \   static __interwork __softfp void NVIC_ClearPendingIRQ(IRQn_Type)
   \                     NVIC_ClearPendingIRQ: (+1)
   \   00000000   0x2101             MOVS     R1,#+1
   \   00000002   0xF010 0x021F      ANDS     R2,R0,#0x1F
   \   00000006   0x4091             LSLS     R1,R1,R2
   \   00000008   0x....             LDR.N    R2,??DataTable6_1  ;; 0xe000e280
   \   0000000A   0xB240             SXTB     R0,R0            ;; SignExt  R0,R0,#+24,#+24
   \   0000000C   0x0943             LSRS     R3,R0,#+5
   \   0000000E   0xF842 0x1023      STR      R1,[R2, R3, LSL #+2]
   \   00000012   0x4770             BX       LR               ;; return
     58          
     59          /***********************************************************************************************************************
     60          Global variable definitions with scope across entire project.
     61          All Global variable names shall start with "G_"
     62          ***********************************************************************************************************************/
     63          /* New variables */

   \                                 In section .bss, align 4
     64          volatile u32 G_u32Adc12Flags;                       /* Global state flags */
   \                     G_u32Adc12Flags:
   \   00000000                      DS8 4
     65          
     66          
     67          /*--------------------------------------------------------------------------------------------------------------------*/
     68          /* Existing variables (defined in other files -- should all contain the "extern" keyword) */
     69          extern volatile u32 G_u32SystemFlags;                  /* From main.c */
     70          extern volatile u32 G_u32ApplicationFlags;             /* From main.c */
     71          
     72          extern volatile u32 G_u32SystemTime1ms;                /* From board-specific source file */
     73          extern volatile u32 G_u32SystemTime1s;                 /* From board-specific source file */
     74          
     75          
     76          /***********************************************************************************************************************
     77          Global variable definitions with scope limited to this local application.
     78          Variable names shall start with "Adc12_" and be declared as static.
     79          ***********************************************************************************************************************/

   \                                 In section .bss, align 4
     80          static fnCode_type Adc12_StateMachine;                /* The state machine function pointer */
   \                     Adc12_StateMachine:
   \   00000000                      DS8 4
     81          //static u32 Adc12_u32Timeout;                        /* Timeout counter used across states */
     82          

   \                                 In section .data, align 4
     83          static Adc12ChannelType Adc12_aeChannels[] = ADC_CHANNEL_ARRAY;  /* Available channels defined in configuration.h */
   \                     Adc12_aeChannels:
   \   00000000   0x01 0x02          DC8 1, 2, 3, 0
   \              0x03 0x00    

   \                                 In section .bss, align 4
     84          static fnCode_u16_type Adc12_afCallbacks[8];          /* ADC12 ISR callback function pointers */
   \                     Adc12_afCallbacks:
   \   00000000                      DS8 32
     85          

   \                                 In section .bss, align 1
     86          static bool Adc12_bAdcAvailable;                      /* Binary semaphore to control access to the ADC12 peripheral */
   \                     Adc12_bAdcAvailable:
   \   00000000                      DS8 1
     87          
     88          
     89          /**********************************************************************************************************************
     90          Function Definitions
     91          **********************************************************************************************************************/
     92          
     93          /*--------------------------------------------------------------------------------------------------------------------*/
     94          /* Public functions                                                                                                   */
     95          /*--------------------------------------------------------------------------------------------------------------------*/
     96          
     97          /*----------------------------------------------------------------------------------------------------------------------
     98          Function: Adc12AssignCallback
     99          
    100          Description
    101          Allows user to specify a custom callback function for when the ADC12 interrupt occurs.
    102          
    103          Requires:
    104            - eAdcChannel_ is the channel to which the callback will be assigned
    105            - fpUserCallback_ is the function address (name) for the user's callback
    106          
    107          Promises:
    108            - Adc12_fpCallbackCh<eAdcChannel_> loaded with fpUserCallback_
    109          */

   \                                 In section .text, align 2, keep-with-next
    110          void Adc12AssignCallback(Adc12ChannelType eAdcChannel_, fnCode_u16_type fpUserCallback_)
    111          {
   \                     Adc12AssignCallback: (+1)
   \   00000000   0xB570             PUSH     {R4-R6,LR}
   \   00000002   0x0004             MOVS     R4,R0
   \   00000004   0x000D             MOVS     R5,R1
    112            bool bChannelValid = FALSE;
   \   00000006   0x2600             MOVS     R6,#+0
    113          
    114            /* Check to ensure the requested channel exists */
    115            for(u8 i = 0; i < (sizeof(Adc12_aeChannels) / sizeof (Adc12ChannelType)); i++)
   \   00000008   0x2000             MOVS     R0,#+0
   \                     ??Adc12AssignCallback_0: (+1)
   \   0000000A   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000000C   0x2803             CMP      R0,#+3
   \   0000000E   0xD209             BCS.N    ??Adc12AssignCallback_1
    116            {
    117              if(Adc12_aeChannels[i] == eAdcChannel_)
   \   00000010   0x....             LDR.N    R1,??DataTable6_2
   \   00000012   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000014   0x5C41             LDRB     R1,[R0, R1]
   \   00000016   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   00000018   0x42A1             CMP      R1,R4
   \   0000001A   0xD101             BNE.N    ??Adc12AssignCallback_2
    118              {
    119                bChannelValid = TRUE;
   \   0000001C   0x2101             MOVS     R1,#+1
   \   0000001E   0x000E             MOVS     R6,R1
    120              }
    121            }
   \                     ??Adc12AssignCallback_2: (+1)
   \   00000020   0x1C40             ADDS     R0,R0,#+1
   \   00000022   0xE7F2             B.N      ??Adc12AssignCallback_0
    122            
    123            /* If the channel is valid, then assign the new callback function */
    124            if(bChannelValid)
   \                     ??Adc12AssignCallback_1: (+1)
   \   00000024   0xB2F6             UXTB     R6,R6            ;; ZeroExt  R6,R6,#+24,#+24
   \   00000026   0x2E00             CMP      R6,#+0
   \   00000028   0xD004             BEQ.N    ??Adc12AssignCallback_3
    125            {
    126              Adc12_afCallbacks[eAdcChannel_] = fpUserCallback_;
   \   0000002A   0x....             LDR.N    R0,??DataTable6_3
   \   0000002C   0xB2E4             UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
   \   0000002E   0xF840 0x5024      STR      R5,[R0, R4, LSL #+2]
   \   00000032   0xE002             B.N      ??Adc12AssignCallback_4
    127            }
    128            else
    129            {
    130              DebugPrintf("Invalid channel\n\r");
   \                     ??Adc12AssignCallback_3: (+1)
   \   00000034   0x....             LDR.N    R0,??DataTable6_4
   \   00000036   0x.... 0x....      BL       DebugPrintf
    131            }
    132            
    133          } /* end Adc12AssignCallback() */
   \                     ??Adc12AssignCallback_4: (+1)
   \   0000003A   0xBD70             POP      {R4-R6,PC}       ;; return
    134          
    135          
    136          /*----------------------------------------------------------------------------------------------------------------------
    137          Function: Adc12StartConversion
    138          
    139          Description
    140          Starts the conversion on the selected channel if the ADC is ready.
    141          If the ADC is busy, the function returns FALSE so the calling application knows
    142          to wait and try later.
    143          
    144          Requires:
    145            - eAdcChannel_ is the ADC12 channel to disable
    146            - Adc12_bAdcAvailable indicates if the ADC is available for a conversion
    147          
    148          Promises:
    149          If Adc12_bAdcAvailable is TRUE:
    150            - Adc12_bAdcAvailable changed to false
    151            - ADC12B_CHER bit for eAdcChannel_ is set
    152            - ADC12B_IER bit for eAdcChannel_is set
    153            - Returns TRUE
    154          
    155          If Adc12_bAdcAvailable is FALSE:
    156            - Returns FALSE
    157          */

   \                                 In section .text, align 2, keep-with-next
    158          bool Adc12StartConversion(Adc12ChannelType eAdcChannel_)
    159          {
   \                     Adc12StartConversion: (+1)
   \   00000000   0x0001             MOVS     R1,R0
    160            if(Adc12_bAdcAvailable)
   \   00000002   0x....             LDR.N    R0,??DataTable6_5
   \   00000004   0x7800             LDRB     R0,[R0, #+0]
   \   00000006   0x2800             CMP      R0,#+0
   \   00000008   0xD012             BEQ.N    ??Adc12StartConversion_0
    161            {
    162              /* Take the semaphore so we have the ADC resource.  Since this is a binary semaphore 
    163              that is only cleared in the ISR, it is safe to do this with interrupts enabled */
    164              Adc12_bAdcAvailable = FALSE;
   \   0000000A   0x2000             MOVS     R0,#+0
   \   0000000C   0x....             LDR.N    R2,??DataTable6_5
   \   0000000E   0x7010             STRB     R0,[R2, #+0]
    165             
    166              /* Enable the channel and its interrupt */
    167              AT91C_BASE_ADC12B->ADC12B_CHER = (1 << eAdcChannel_);
   \   00000010   0x2001             MOVS     R0,#+1
   \   00000012   0x4088             LSLS     R0,R0,R1
   \   00000014   0x....             LDR.N    R2,??DataTable6_6  ;; 0x400a8010
   \   00000016   0x6010             STR      R0,[R2, #+0]
    168              AT91C_BASE_ADC12B->ADC12B_IER  = (1 << eAdcChannel_);
   \   00000018   0x2001             MOVS     R0,#+1
   \   0000001A   0x4088             LSLS     R0,R0,R1
   \   0000001C   0x....             LDR.N    R2,??DataTable6_7  ;; 0x400a8024
   \   0000001E   0x6010             STR      R0,[R2, #+0]
    169            
    170              /* Start the conversion and exit */
    171              AT91C_BASE_ADC12B->ADC12B_CR |= AT91C_ADC12B_CR_START;
   \   00000020   0x....             LDR.N    R0,??DataTable6_8  ;; 0x400a8000
   \   00000022   0x6800             LDR      R0,[R0, #+0]
   \   00000024   0xF050 0x0002      ORRS     R0,R0,#0x2
   \   00000028   0x....             LDR.N    R2,??DataTable6_8  ;; 0x400a8000
   \   0000002A   0x6010             STR      R0,[R2, #+0]
    172              return TRUE;
   \   0000002C   0x2001             MOVS     R0,#+1
   \   0000002E   0xE000             B.N      ??Adc12StartConversion_1
    173            }
    174            
    175            /* The ADC is not available */
    176            return FALSE;
   \                     ??Adc12StartConversion_0: (+1)
   \   00000030   0x2000             MOVS     R0,#+0
   \                     ??Adc12StartConversion_1: (+1)
   \   00000032   0x4770             BX       LR               ;; return
    177          
    178          } /* end Adc12StartConversion() */
    179          
    180          
    181          /*--------------------------------------------------------------------------------------------------------------------*/
    182          /* Protected functions                                                                                                */
    183          /*--------------------------------------------------------------------------------------------------------------------*/
    184          
    185          /*--------------------------------------------------------------------------------------------------------------------
    186          Function: Adc12Initialize
    187          
    188          Description:
    189          Initializes the State Machine and its variables.
    190          
    191          Requires:
    192            -
    193          
    194          Promises:
    195            - 
    196          */

   \                                 In section .text, align 2, keep-with-next
    197          void Adc12Initialize(void)
    198          {
   \                     Adc12Initialize: (+1)
   \   00000000   0xB500             PUSH     {LR}
   \   00000002   0xB087             SUB      SP,SP,#+28
    199            u8 au8Adc12Started[] = "ADC12 task initialized\n\r";
   \   00000004   0xA800             ADD      R0,SP,#+0
   \   00000006   0x....             LDR.N    R1,??DataTable6_9
   \   00000008   0x2219             MOVS     R2,#+25
   \   0000000A   0x.... 0x....      BL       __aeabi_memcpy
    200          
    201            /* Initialize peripheral registers. ADC starts totally disabled. */
    202            AT91C_BASE_ADC12B->ADC12B_MR   = ADC12B_MR_INIT;
   \   0000000E   0x....             LDR.N    R0,??DataTable6_10  ;; 0xf041700
   \   00000010   0x....             LDR.N    R1,??DataTable6_11  ;; 0x400a8004
   \   00000012   0x6008             STR      R0,[R1, #+0]
    203            AT91C_BASE_ADC12B->ADC12B_CHDR = ADC12B_CHDR_INIT;
   \   00000014   0x20FF             MOVS     R0,#+255
   \   00000016   0x....             LDR.N    R1,??DataTable6_12  ;; 0x400a8014
   \   00000018   0x6008             STR      R0,[R1, #+0]
    204            AT91C_BASE_ADC12B->ADC12B_ACR  = ADC12B_ACR_INIT;
   \   0000001A   0xF240 0x1001      MOVW     R0,#+257
   \   0000001E   0x....             LDR.N    R1,??DataTable6_13  ;; 0x400a8064
   \   00000020   0x6008             STR      R0,[R1, #+0]
    205            AT91C_BASE_ADC12B->ADC12B_EMR  = ADC12B_EMR_INIT;
   \   00000022   0x....             LDR.N    R0,??DataTable6_14  ;; 0x40001
   \   00000024   0x....             LDR.N    R1,??DataTable6_15  ;; 0x400a8068
   \   00000026   0x6008             STR      R0,[R1, #+0]
    206            AT91C_BASE_ADC12B->ADC12B_IDR  = ADC12B_IDR_INIT;
   \   00000028   0x....             LDR.N    R0,??DataTable6_16  ;; 0xfffff
   \   0000002A   0x....             LDR.N    R1,??DataTable6_17  ;; 0x400a8028
   \   0000002C   0x6008             STR      R0,[R1, #+0]
    207            
    208            /* Set all the callbacks to default */
    209            for(u8 i = 0; i < (sizeof(Adc12_afCallbacks) / sizeof(fnCode_u16_type)); i++)
   \   0000002E   0x2000             MOVS     R0,#+0
   \                     ??Adc12Initialize_0: (+1)
   \   00000030   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   00000032   0x2808             CMP      R0,#+8
   \   00000034   0xD207             BCS.N    ??Adc12Initialize_1
    210            {
    211              Adc12_afCallbacks[i] = Adc12DefaultCallback;
   \   00000036   0x.... 0x....      ADR.W    R1,Adc12DefaultCallback
   \   0000003A   0x....             LDR.N    R2,??DataTable6_3
   \   0000003C   0xB2C0             UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
   \   0000003E   0xF842 0x1020      STR      R1,[R2, R0, LSL #+2]
    212            }
   \   00000042   0x1C40             ADDS     R0,R0,#+1
   \   00000044   0xE7F4             B.N      ??Adc12Initialize_0
    213            
    214            /* Mark the ADC semaphore as available */
    215            Adc12_bAdcAvailable = TRUE;
   \                     ??Adc12Initialize_1: (+1)
   \   00000046   0x2001             MOVS     R0,#+1
   \   00000048   0x....             LDR.N    R1,??DataTable6_5
   \   0000004A   0x7008             STRB     R0,[R1, #+0]
    216            
    217            /* If good initialization, set state to Idle */
    218            if( 1 )
    219            {
    220              /* Enable required interrupts */
    221              NVIC_ClearPendingIRQ(IRQn_ADCC0);
   \   0000004C   0x201A             MOVS     R0,#+26
   \   0000004E   0x.... 0x....      BL       NVIC_ClearPendingIRQ
    222              NVIC_EnableIRQ(IRQn_ADCC0);
   \   00000052   0x201A             MOVS     R0,#+26
   \   00000054   0x.... 0x....      BL       NVIC_EnableIRQ
    223              DebugPrintf(au8Adc12Started);
   \   00000058   0xA800             ADD      R0,SP,#+0
   \   0000005A   0x.... 0x....      BL       DebugPrintf
    224              Adc12_StateMachine = Adc12SM_Idle;
   \   0000005E   0x.... 0x....      ADR.W    R0,Adc12SM_Idle
   \   00000062   0x....             LDR.N    R1,??DataTable6_18
   \   00000064   0x6008             STR      R0,[R1, #+0]
    225            }
    226            else
    227            {
    228              /* The task isn't properly initialized, so shut it down and don't run */
    229              Adc12_StateMachine = Adc12SM_FailedInit;
    230            }
    231          
    232          } /* end Adc12Initialize() */
   \   00000066   0xB007             ADD      SP,SP,#+28
   \   00000068   0xBD00             POP      {PC}             ;; return
    233          
    234          
    235          /*----------------------------------------------------------------------------------------------------------------------
    236          Function Adc12RunActiveState()
    237          
    238          Description:
    239          Selects and runs one iteration of the current state in the state machine.
    240          All state machines have a TOTAL of 1ms to execute, so on average n state machines
    241          may take 1ms / n to execute.
    242          
    243          Requires:
    244            - State machine function pointer points at current state
    245          
    246          Promises:
    247            - Calls the function to pointed by the state machine function pointer
    248          */

   \                                 In section .text, align 2, keep-with-next
    249          void Adc12RunActiveState(void)
    250          {
   \                     Adc12RunActiveState: (+1)
   \   00000000   0xB580             PUSH     {R7,LR}
    251            Adc12_StateMachine();
   \   00000002   0x....             LDR.N    R0,??DataTable6_18
   \   00000004   0x6800             LDR      R0,[R0, #+0]
   \   00000006   0x4780             BLX      R0
    252          
    253          } /* end Adc12RunActiveState */
   \   00000008   0xBD01             POP      {R0,PC}          ;; return
    254          
    255          
    256          /*--------------------------------------------------------------------------------------------------------------------*/
    257          /* Private functions                                                                                                  */
    258          /*--------------------------------------------------------------------------------------------------------------------*/
    259          
    260          /*----------------------------------------------------------------------------------------------------------------------
    261          Function Adc12DefaultCallback()
    262          
    263          Description:
    264          An empty function that the unset Adc Callbacks point to.  Expected that the 
    265          user will set their own.
    266          
    267          Requires:
    268            - 
    269          
    270          Promises:
    271            - 
    272          */

   \                                 In section .text, align 4, keep-with-next
    273          void Adc12DefaultCallback(u16 u16Result_)
    274          {
    275          } /* End Adc12DefaultCallback() */
   \                     Adc12DefaultCallback: (+1)
   \   00000000   0x4770             BX       LR               ;; return
    276          
    277          
    278          /*----------------------------------------------------------------------------------------------------------------------
    279          ISR: ADCC0_IrqHandler
    280          
    281          Description:
    282          Parses the ADC12 interrupts and handles them appropriately.  Note that all ADC12
    283          interrupts are ORed and will trigger this handler, therefore any expected interrupt 
    284          that is enabled must be parsed out and handled.  There is no obviously available
    285          explanation for why this handler is called ADCC0_IrqHandler instead of ADC12B_IrqHandler
    286          
    287          Requires:
    288            - Only one channel can be converting at a time, so only one interrupt flag
    289              will be set.
    290          
    291          Promises:
    292            - 
    293          */

   \                                 In section .text, align 2, keep-with-next
    294          void ADCC0_IrqHandler(void)
    295          {
   \                     ADCC0_IrqHandler: (+1)
   \   00000000   0xB538             PUSH     {R3-R5,LR}
    296            u16 u16Adc12Result;
    297            /* WARNING: if you step through this handler with the ADC12B registers
    298            debugging, the debugger reads ADC12B_SR and clears the EOC flag bits */
    299            
    300          
    301            /* Check through all the available channels */
    302            for(u8 i = 0; i < (sizeof(Adc12_aeChannels) / sizeof(Adc12ChannelType)); i++)
   \   00000002   0x2500             MOVS     R5,#+0
   \                     ??ADCC0_IrqHandler_0: (+1)
   \   00000004   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000006   0x2D03             CMP      R5,#+3
   \   00000008   0xD221             BCS.N    ??ADCC0_IrqHandler_1
    303            {
    304              if(AT91C_BASE_ADC12B->ADC12B_SR & (1 << Adc12_aeChannels[i]))
   \   0000000A   0x....             LDR.N    R0,??DataTable6_19  ;; 0x400a801c
   \   0000000C   0x6800             LDR      R0,[R0, #+0]
   \   0000000E   0x....             LDR.N    R1,??DataTable6_2
   \   00000010   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000012   0x5C69             LDRB     R1,[R5, R1]
   \   00000014   0x40C8             LSRS     R0,R0,R1
   \   00000016   0x07C0             LSLS     R0,R0,#+31
   \   00000018   0xD517             BPL.N    ??ADCC0_IrqHandler_2
    305              {
    306                /* Read the channel's result register (clears EOC bit / interrupt) and send to callback */
    307                u16Adc12Result = AT91C_BASE_ADC12B->ADC12B_CDR[Adc12_aeChannels[i]];
   \   0000001A   0x....             LDR.N    R0,??DataTable6_20  ;; 0x400a8030
   \   0000001C   0x....             LDR.N    R1,??DataTable6_2
   \   0000001E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000020   0x5C69             LDRB     R1,[R5, R1]
   \   00000022   0xF850 0x0021      LDR      R0,[R0, R1, LSL #+2]
   \   00000026   0x0004             MOVS     R4,R0
    308                Adc12_afCallbacks[Adc12_aeChannels[i]](u16Adc12Result);
   \   00000028   0x0020             MOVS     R0,R4
   \   0000002A   0xB280             UXTH     R0,R0            ;; ZeroExt  R0,R0,#+16,#+16
   \   0000002C   0x....             LDR.N    R1,??DataTable6_3
   \   0000002E   0x....             LDR.N    R2,??DataTable6_2
   \   00000030   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000032   0x5CAA             LDRB     R2,[R5, R2]
   \   00000034   0xF851 0x1022      LDR      R1,[R1, R2, LSL #+2]
   \   00000038   0x4788             BLX      R1
    309                
    310                /* Disable the channel and exit the loop since only one channel can be set */
    311                AT91C_BASE_ADC12B->ADC12B_CHDR = (1 << Adc12_aeChannels[i]);
   \   0000003A   0x2001             MOVS     R0,#+1
   \   0000003C   0x....             LDR.N    R1,??DataTable6_2
   \   0000003E   0xB2ED             UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
   \   00000040   0x5669             LDRSB    R1,[R5, R1]
   \   00000042   0x4088             LSLS     R0,R0,R1
   \   00000044   0x....             LDR.N    R1,??DataTable6_12  ;; 0x400a8014
   \   00000046   0x6008             STR      R0,[R1, #+0]
    312                break;
   \   00000048   0xE001             B.N      ??ADCC0_IrqHandler_1
    313              }
    314            }
   \                     ??ADCC0_IrqHandler_2: (+1)
   \   0000004A   0x1C6D             ADDS     R5,R5,#+1
   \   0000004C   0xE7DA             B.N      ??ADCC0_IrqHandler_0
    315            
    316            /* Give the Semaphore back, clear the ADC pending flag and exit */
    317            Adc12_bAdcAvailable = TRUE;
   \                     ??ADCC0_IrqHandler_1: (+1)
   \   0000004E   0x2001             MOVS     R0,#+1
   \   00000050   0x....             LDR.N    R1,??DataTable6_5
   \   00000052   0x7008             STRB     R0,[R1, #+0]
    318            NVIC->ICPR[0] = (1 << AT91C_ID_ADC12B);
   \   00000054   0xF05F 0x6080      MOVS     R0,#+67108864
   \   00000058   0x....             LDR.N    R1,??DataTable6_1  ;; 0xe000e280
   \   0000005A   0x6008             STR      R0,[R1, #+0]
    319            
    320          } /* end ADCC0_IrqHandler() */
   \   0000005C   0xBD31             POP      {R0,R4,R5,PC}    ;; return
    321          
    322          
    323          /**********************************************************************************************************************
    324          State Machine Function Definitions
    325          **********************************************************************************************************************/
    326          
    327          /*-------------------------------------------------------------------------------------------------------------------*/
    328          /* Wait for a message to be queued */

   \                                 In section .text, align 4, keep-with-next
    329          static void Adc12SM_Idle(void)
    330          {
    331              
    332          } /* end Adc12SM_Idle() */
   \                     Adc12SM_Idle: (+1)
   \   00000000   0x4770             BX       LR               ;; return

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6:
   \   00000000   0xE000E100         DC32     0xe000e100

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_1:
   \   00000000   0xE000E280         DC32     0xe000e280

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_2:
   \   00000000   0x........         DC32     Adc12_aeChannels

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_3:
   \   00000000   0x........         DC32     Adc12_afCallbacks

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_4:
   \   00000000   0x........         DC32     ?_0

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_5:
   \   00000000   0x........         DC32     Adc12_bAdcAvailable

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_6:
   \   00000000   0x400A8010         DC32     0x400a8010

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_7:
   \   00000000   0x400A8024         DC32     0x400a8024

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_8:
   \   00000000   0x400A8000         DC32     0x400a8000

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_9:
   \   00000000   0x........         DC32     ?_1

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_10:
   \   00000000   0x0F041700         DC32     0xf041700

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_11:
   \   00000000   0x400A8004         DC32     0x400a8004

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_12:
   \   00000000   0x400A8014         DC32     0x400a8014

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_13:
   \   00000000   0x400A8064         DC32     0x400a8064

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_14:
   \   00000000   0x00040001         DC32     0x40001

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_15:
   \   00000000   0x400A8068         DC32     0x400a8068

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_16:
   \   00000000   0x000FFFFF         DC32     0xfffff

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_17:
   \   00000000   0x400A8028         DC32     0x400a8028

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_18:
   \   00000000   0x........         DC32     Adc12_StateMachine

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_19:
   \   00000000   0x400A801C         DC32     0x400a801c

   \                                 In section .text, align 4, keep-with-next
   \                     ??DataTable6_20:
   \   00000000   0x400A8030         DC32     0x400a8030

   \                                 In section .rodata, align 4
   \                     ?_0:
   \   00000000   0x49 0x6E          DC8 "Invalid channel\012\015"
   \              0x76 0x61    
   \              0x6C 0x69    
   \              0x64 0x20    
   \              0x63 0x68    
   \              0x61 0x6E    
   \              0x6E 0x65    
   \              0x6C 0x0A    
   \              0x0D 0x00    
   \   00000012   0x00 0x00          DC8 0, 0

   \                                 In section .rodata, align 4
   \                     ?_1:
   \   00000000   0x41 0x44          DC8 "ADC12 task initialized\012\015"
   \              0x43 0x31    
   \              0x32 0x20    
   \              0x74 0x61    
   \              0x73 0x6B    
   \              0x20 0x69    
   \              0x6E 0x69    
   \              0x74 0x69    
   \              0x61 0x6C    
   \              0x69 0x7A    
   \              0x65 0x64    
   \              0x0A 0x0D    
   \              0x00         
   \   00000019   0x00 0x00          DC8 0, 0, 0
   \              0x00         
    333               
    334          
    335          #if 0
    336          /*-------------------------------------------------------------------------------------------------------------------*/
    337          /* Handle an error */
    338          static void Adc12SM_Error(void)          
    339          {
    340            
    341          } /* end Adc12SM_Error() */
    342          #endif
    343          
    344          
    345          /*-------------------------------------------------------------------------------------------------------------------*/
    346          /* State to sit in if init failed */
    347          static void Adc12SM_FailedInit(void)          
    348          {
    349              
    350          } /* end Adc12SM_FailedInit() */
    351          
    352          
    353          /*--------------------------------------------------------------------------------------------------------------------*/
    354          /* End of File                                                                                                        */
    355          /*--------------------------------------------------------------------------------------------------------------------*/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   ADCC0_IrqHandler
        16   -- Indirect call
      16   Adc12AssignCallback
        16   -> DebugPrintf
       0   Adc12DefaultCallback
      32   Adc12Initialize
        32   -> DebugPrintf
        32   -> NVIC_ClearPendingIRQ
        32   -> NVIC_EnableIRQ
        32   -> __aeabi_memcpy
       8   Adc12RunActiveState
         8   -- Indirect call
       0   Adc12SM_Idle
       0   Adc12StartConversion
       0   NVIC_ClearPendingIRQ
       0   NVIC_EnableIRQ


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_13
       4  ??DataTable6_14
       4  ??DataTable6_15
       4  ??DataTable6_16
       4  ??DataTable6_17
       4  ??DataTable6_18
       4  ??DataTable6_19
       4  ??DataTable6_2
       4  ??DataTable6_20
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
      20  ?_0
      28  ?_1
      94  ADCC0_IrqHandler
      60  Adc12AssignCallback
       2  Adc12DefaultCallback
     106  Adc12Initialize
      10  Adc12RunActiveState
       2  Adc12SM_Idle
      52  Adc12StartConversion
       4  Adc12_StateMachine
       4  Adc12_aeChannels
      32  Adc12_afCallbacks
       1  Adc12_bAdcAvailable
       4  G_u32Adc12Flags
      20  NVIC_ClearPendingIRQ
      20  NVIC_EnableIRQ

 
  41 bytes in section .bss
   4 bytes in section .data
  48 bytes in section .rodata
 450 bytes in section .text
 
 450 bytes of CODE  memory
  48 bytes of CONST memory
  45 bytes of DATA  memory

Errors: none
Warnings: none
